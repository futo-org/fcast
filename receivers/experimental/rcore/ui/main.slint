import {
    Icons,
    FText,
    ScrollView,
    Spinner,
    Button,
    Palette,
    ListView,
    Slider,
} from "../../../../senders/ui-components/std-widgets.slint";
import { FCastPalette } from "../../../../senders/ui-components/styling.slint";
import "../../../../senders/ui-components/fonts/Outfit-Regular.ttf";

export enum GuiPlaybackState {
    Idle,
    Playing,
    Paused,
    Loading,
}

export enum AppState {
    Idle,
    LoadingMedia,
    Playing,
}

export enum UiPlayerVariant {
    Unknown,
    Image,
    Audio,
    Video,
}

export struct UiSubOverlay {
    img: image,
    x: length,
    y: length,
}

export struct UiStreamDbg {
    id: string,
    codec: string,
}

export struct UiAudioStreamDbg {
    info: UiStreamDbg,
    bitrate: string,
    channels: int,
    language: string,
    max_bitrate: string,
    sample_rate: int,
}

export struct UiVideoStreamDbg {
    info: UiStreamDbg,
    bitrate: string,
    max_bitrate: string,
    framerate_n: int,
    framerate_d: int,
    width: int,
    height: int,
}

export struct UiSubtitleStreamDbg {
    info: UiStreamDbg,
    language: string,
}

export global Bridge {
    in property <string> label;
    in property <string> progress-label;
    in property <string> duration-label;
    in property <AppState> app-state: AppState.Idle;
    in property <[UiSubOverlay]> overlays;
    in property <bool> is-live: false;
    in property <string> media-title;
    in property <string> artist-name;
    in property <bool> is-fullscreen;
    in property <image> qr-code;
    in property <image> video-frame;
    in property <image> image-preview;
    in property <image> audio-track-cover;
    in property <image> blured-audio-track-cover;
    in property <[UiAudioStreamDbg]> audio-dbg;
    in property <[UiVideoStreamDbg]> video-dbg;
    in property <[UiSubtitleStreamDbg]> subtitle-dbg;

    in-out property <GuiPlaybackState> playback-state: GuiPlaybackState.Idle;
    in-out property <bool> playing: false;
    in-out property <float> volume: 1.0;
    in-out property <bool> is-debugging: false;
    in-out property <int> connected_devices: 0;
    in-out property <float> playback-position: 0.0;
    in-out property <bool> is-scrubbing-position: false;
    in-out property <UiPlayerVariant> player-variant: UiPlayerVariant.Unknown;

    out property <brush> controls-bg-gradient: @linear-gradient(0deg, rgba(0, 0, 0, 0.75) 0%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.60) 100%, rgba(0, 0, 0, 0));

    callback resume-or-pause();
    callback seek-to-percent(float);
    callback toggle-fullscreen();
    callback set-volume(float);
    callback force-quit();
    callback debug-toggled();

    public pure function gui-playback-state-to-string(pbstate: GuiPlaybackState) -> string {
        if (pbstate == GuiPlaybackState.Idle) {
            return "Idle";
        }
        if (pbstate == GuiPlaybackState.Playing) {
            return "Playing";
        }
        if (pbstate == GuiPlaybackState.Paused) {
            return "Paused";
        }
        if (pbstate == GuiPlaybackState.Loading) {
            return "Loading";
        }
        return "Invalid";
    }

    public function toggle-debug-mode() {
        is-debugging = !is-debugging;
        debug-toggled();
    }

    public function device-disconnected() {
        connected_devices = max(connected_devices - 1, 0);
    }

    public function capture-key-pressed(event: KeyEvent) -> EventResult {
        if event.text == "q" {
            force-quit();
            return accept;
        } else if event.text == "d" {
            toggle-debug-mode();
            return accept;
        } else if event.text == "f" {
            toggle-fullscreen();
            return accept;
        } else if Bridge.playing && event.text == Key.Space {
            resume-or-pause();
            return accept;
        } else if Bridge.playing && (event.text == Key.LeftArrow || event.text == Key.RightArrow || event.text == Key.UpArrow || event.text == Key.DownArrow || event.text == Key.Return) {
            // TODO: do something
        }
        reject
    }
}

component ProgressLabelBox inherits Rectangle {
    in property <string> text <=> txt.text;

    background: FCastPalette.opacity-light-1000;
    border-radius: 12px;
    height: txt.preferred-height + 4px;
    width: txt.preferred-width + 16px;

    txt := Text {
        color: FCastPalette.foreground;
        font-size: 13px;
    }
}

component ProgressLabels inherits HorizontalLayout {
    padding-left: 10px;
    padding-right: self.padding-left;

    ProgressLabelBox {
        text: Bridge.progress-label;
    }

    Rectangle {}

    if !Bridge.is-live: ProgressLabelBox {
        text: Bridge.duration-label;
    }
}

// TODO: animate in and out transitions
component ErrorAlert {
    in property <string> message;

    visible: false;

    public function show() {
        self.visible = true;
        timer.counter = 0;
        timer.running = true;
    }

    function close() {
        self.visible = false;
        timer.running = true;
    }

    states [
        hover when ta.has-hover: {
            im.colorize: #DEDEDE;
        }
    ]

    Rectangle {
        height: hb.preferred-height;
        background: #FF4131;
        border-radius: 8px;

        hb := VerticalLayout {
            spacing: 10px;
            alignment: space-between;

            Text {
                color: white;
                vertical-alignment: center;
                text <=> message;
                wrap: word-wrap;
                font-weight: 800;
            }

            ta := TouchArea {
                height: 32px;
                width: 32px;
                clicked => {
                    root.close();
                }
                Rectangle {
                    im := Image {
                        height: 100%;
                        // source: @image-url("../../assets/icons/xmark.svg");
                        colorize: white;
                        animate colorize { duration: 150ms; }
                    }
                }
            }
        }
    }

    timer := Timer {
        property <int> counter: 0;
        interval: 1s;
        running: true;
        triggered => {
            counter += 1;
            if counter >= 4 {
                root.close();
            }
        }
    }
}

component LoadingMediaView inherits Rectangle {
    Image {
        source: Icons.background-dark;
        width: 100%;
        height: 100%;
    }

    VerticalLayout {
        alignment: center;

        FText {
            text: "Loading media...";
            horizontal-alignment: center;
        }
    }
}

component PositionScrubber inherits Slider {
    hide-thumb: true;
    maximum: 1.0;
    minimum: 0.0;
    value <=> Bridge.playback-position;
    enabled: false;
    rail-color: #FFFFFF33;
    track-color: Bridge.is-live ? FCastPalette.negative-800 : FCastPalette.foreground;
    thumb-color: self.track-color;

    states [
        enabled when Bridge.playback-state != GuiPlaybackState.Loading: {
            enabled: true;
        }
    ]
}

component MasterButton inherits Button {
    height: 60px;
    width: 60px;
    icon-size: 20px;
    enabled: false;
    background-default-color: @linear-gradient(133.14deg, rgba(52, 52, 52, 0.6) 6.7%, rgba(20, 20, 20, 0.6) 92.77%);

    states [
        playing when Bridge.playback-state == GuiPlaybackState.Playing: {
            icon: Icons.pause;
            enabled: true;
        }
        paused when Bridge.playback-state == GuiPlaybackState.Paused: {
            icon: Icons.play;
            enabled: true;
        }
    ]

    clicked => {
        Bridge.resume-or-pause();
    }
}

component PlaybackControls inherits Rectangle {
    // TODO: speed changer

    // in property <string> progress-label;

    // in-out property <GuiPlaybackState> pb-state;

    background: Bridge.controls-bg-gradient;

    out property <MouseCursor> suggested-cursor: default;

    // property <bool> is-scrubbing: false;
    property <bool> is-changing-volume: false;

    public function show() {
        root.visible = true;
        tim.counter = 0;
        tim.running = true;
        suggested-cursor = MouseCursor.default;
    }

    public function close() {
        root.visible = false;
        tim.running = false;
        suggested-cursor = MouseCursor.none;
    }

    public function playback-started() {
        show();
    }

    public function playback-stopped() {
        show();
    }

    public function update-progress-percent(percent: float) {
        // if ! is-scrubbing {
        if !Bridge.is-scrubbing-position {
            scrubber.value = percent;
        }
    }

    function scrubber-changed() {
        // Make the bar not disipear when the user is engaging with the scrubber
        // is-scrubbing = true;
        Bridge.is-scrubbing-position = true;
        show();
    }

    function volume-changed() {
        is-changing-volume = true;
        show();
    }

    // TODO: maybe touch area inside this component

    VerticalLayout {
        padding: 58px;
        padding-top: 20px;
        padding-bottom: 20px;
        spacing: 5px;

        HorizontalLayout {
            Rectangle { }

            Button {
                icon-size: 18px;
                width: 40px;
                height: 40px;

                // TODO: change icon to minimize/maximize
                icon: Icons.subtitles;

                clicked => Bridge.toggle-fullscreen();
            }
        }

        Rectangle { }

        HorizontalLayout {
            padding: 10px;
            padding-bottom: 15px;

            FText {
                text: Bridge.media-title;
                width: 50%;
                wrap: word-wrap;
                overflow: elide;
                font-size: 24px;
                max-height: 5px;
                font-weight: 500;
                color: FCastPalette.neutral-100;
            }

            Rectangle { /* Spacer */ }

            if Bridge.is-live: VerticalLayout {
                Rectangle { }

                Rectangle {
                    background: #FB2C2C;
                    border-radius: 3.3px;
                    width: i-hl.preferred-width;

                    i-hl := HorizontalLayout {
                        padding: 12px;
                        padding-top: 6px;
                        padding-bottom: self.padding-top;
                        spacing: 6px;

                        VerticalLayout {
                            alignment: center;

                            Rectangle {
                                width: 8px;
                                height: 8px;
                                border-radius: 5px;
                                background: FCastPalette.foreground;
                            }
                        }

                        FText {
                            text: "LIVE";
                            font-weight: 500;
                            vertical-alignment: center;
                        }
                    }
                }
            }
        }

        scrubber := PositionScrubber {
            changed(_) => {
                scrubber-changed();
            }
            released(position) => {
                Bridge.is-scrubbing-position = false;
                Bridge.seek-to-percent(position);
            }
        }

        ProgressLabels { }

        Rectangle {
            height: 5px;
        }

        HorizontalLayout {
            alignment: space-between;

            Rectangle {
                width: right-side-ctrls.preferred-width;
            }

            Rectangle {
                MasterButton {
                    height: 50px;
                    width: 50px;
                }
            }

            right-side-ctrls := HorizontalLayout {
                alignment: end;

                Button {
                    icon-size: 18px;
                    width: 40px;
                    height: 40px;
                    icon: Icons.subtitles;
                }
            }
        }
    }

    tim := Timer {
        property <int> counter;
        interval: 500ms;
        running: true;
        triggered => {
            counter += 1;
            // mouse cursor in root root
            // Wait 500ms * 4 before hiding the bar
            if counter >= 4 {
                parent.close();

                // TODO: don't close if user is hovering widgets

                // if fullscreen-btn.is-engaged || volume-btn.is-engaged {
                //     parent.show();
                // } else {
                //     parent.close();
                // }
            }
        }
    }
}

component ReceiverInfoEntry inherits HorizontalLayout {
    in property <image> icon <=> i-icon.source;
    in property <length> icon-width <=> i-icon.width;
    in property <length> icon-height <=> i-icon.height;
    in property <string> key;
    in property <string> value;

    padding: 5px;
    spacing: 15px;

    VerticalLayout {
        alignment: center;

        i-icon := Image {
        }
    }

    VerticalLayout {
        Text {
            text: key;
            color: FCastPalette.opacity-light-700;
            font-size: 12px;
        }

        Text {
            text: value;
            color: FCastPalette.foreground;
            font-size: 14px;
            wrap: word-wrap;
        }
    }

    Rectangle {}
}

component IdleView inherits Rectangle {
    // background: @linear-gradient(155deg, #414141 0%, #000000 100%);

    Image {
        source: Icons.background-dark;
        width: 100%;
        height: 100%;
    }

    VerticalLayout {
        padding: 32px;
        padding-right: 58px;
        padding-left: self.padding-right;
        spacing: 20px;

        HorizontalLayout {
            Rectangle { }

            Button {
                icon-size: 18px;
                width: 40px;
                height: 40px;
                background-default-color: @linear-gradient(133.14deg, rgba(52, 52, 52, 0.1) 6.7%, rgba(20, 20, 20, 0.1) 92.77%);
                icon: Icons.settings;

                // TODO:
            }
        }

        pure function qr-size() -> length {
            let width = Math.min(root.width * 35%, 400px);
            let height = Math.min(root.height * 50%, 750px);
            Math.min(width, height)
        }

        HorizontalLayout {
            alignment: space-between;

            Rectangle {
                width: Math.min(root.width * 45%, 500px);

                VerticalLayout {
                    padding: 10px;
                    spacing: 10px;

                    visible: !Bridge.playing;
                    alignment: center;
                    Text {
                        font-size: 28px;
                        text: "Idle. Ready to cast";
                        font-weight: 600;
                        // horizontal-alignment: center;
                        font-family: "Outfit Semibold";
                        overflow: elide;
                        color: @linear-gradient(180deg, #FFFFFF 17.11%, #B4B4B4 78.95%);
                    }

                    if root.height > 380px: Text {
                        font-size: 12pt;
                        text: "Stream to this device by opening your FCast sender app and selecting this device from the Cast menu, or scan the QR code for instant setup.";
                        wrap: word-wrap;
                        // horizontal-alignment: center;
                        color: FCastPalette.opacity-light-500;
                    }

                    Rectangle {
                        background: @linear-gradient(222.86deg, #262626 7.47%, #0E0F10 95.53%);
                        border-radius: 8px;
                        border-width: 1px;
                        border-color: @linear-gradient(180deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0) 100%);

                        VerticalLayout {
                            padding: 10px;
                            spacing: 3px;

                            ReceiverInfoEntry {
                                icon: Icons.tv-outline;
                                icon-width: 15px;
                                icon-height: 12.3px;
                                key: "Device name";
                                value: "FCast-todo...";
                            }

                            Rectangle {
                                height: 1px;
                                background: FCastPalette.opacity-light-1100;
                            }

                            ReceiverInfoEntry {
                                icon: Icons.network;
                                icon-width: 13.3px;
                                icon-height: 14px;
                                key: "Local IP Address";
                                value: "127.0.0.1, 127.0.0.1, 127.0.0.1";
                            }
                        }
                    }
                }
            }

            // Rectangle { }

            VerticalLayout {
                alignment: center;

                Rectangle {
                    width: qr-size();
                    height: self.width;
                    border-radius: 8px;
                    clip: true;
                    background: Bridge.qr-code.width > 0 ? white : @linear-gradient(222.86deg, #262626 7.47%, #0E0F10 95.53%);

                    if Bridge.qr-code.width > 0: Image {
                        width: parent.width - 20px;
                        height: parent.height - 20px;
                        source <=> Bridge.qr-code;
                        image-rendering: pixelated;
                    }

                    if Bridge.qr-code.width == 0: VerticalLayout {
                        alignment: center;
                        spacing: 20px;
                        padding: 15px;

                        Rectangle {
                            Image {
                                source: @image-url("warning-triangle.svg");
                                width: 80px;
                            }

                            Image {
                                source: @image-url("exclamation-mark.svg");
                                width: 60px;
                            }
                        }

                        FText {
                            text: "Your device isnâ€™t connected to a network. Connect to network via LAN or Wifi to continue.";
                            wrap: word-wrap;
                            horizontal-alignment: center;
                            font-size: 18px;
                        }
                    }
                }
            }
        }
    }
}

component VideoPlayerView inherits Rectangle {
    width: 100%;
    height: 100%;
    background: black;

    vframe := Image {
        source <=> Bridge.video-frame;
        image-fit: contain;
        width: 100%;
        height: 100%;
    }

    pure function scale() -> length {
        Math.min(root.height / vframe.source.height, root.width / vframe.source.width)
    }

    pure function frame-x() -> length {
        root.width / 2 - vframe.source.width * scale() / 2
    }

    pure function frame-y() -> length {
        root.height / 2 - vframe.source.height * scale() / 2
    }

    for overlay in Bridge.overlays: Image {
        x: frame-x() + (overlay.x * scale() / 1px);
        y: frame-y() + (overlay.y * scale() / 1px);
        width: scale() * overlay.img.width;
        height: scale() * overlay.img.height;
        source: overlay.img;
    }

    TouchArea {
        width: 100%;
        height: 100%;

        visible: Bridge.playing;

        mouse-cursor: self.visible && !playback-control.visible ? none : default;

        FocusScope {
            capture-key-pressed(event) => Bridge.capture-key-pressed(event);
        }

        pointer-event(pe) => {
            if (pe.kind == PointerEventKind.move) {
                playback-control.show();
            }
        }

        playback-control := PlaybackControls {
            // visible: false;
            visible: true;
            width: 100%;
            height: 100%;
            // y: parent.height - self.height;
            // progress-label <=> Bridge.progress-label;
            // pb-state: Bridge.playback-state;
        }
    }
}

component ImageView inherits Rectangle {
    width: 100%;
    height: 100%;
    background: black;

    Image {
        source <=> Bridge.image-preview;
        image-fit: contain;
        width: 100%;
        height: 100%;
    }
}

component AudioView inherits Rectangle {
    background: FCastPalette.neutral-1100;

    property <bool> small-mode: root.height <= (500px +  (Bridge.media-title.is-empty ? 0px : 35px) + (Bridge.artist-name.is-empty ? 0px : 25px));

    Image {
        image-fit: cover;
        source: Bridge.blured-audio-track-cover;
        width: 100%;
        height: 100%;
    }

    if Bridge.blured-audio-track-cover.width > 0: Rectangle {
        background: Bridge.controls-bg-gradient;
    }

    VerticalLayout {
        padding: !small-mode ? 58px : 10px;
        padding-bottom: 20px;
        spacing: 5px;
        alignment: center;

        if root.height > 300px: HorizontalLayout {
            alignment: center;

            pure function thumbnail-size() -> length {
                let width = Math.min(root.width * (!small-mode ? 35% : 10%), 400px);
                let height = Math.min(root.height * (!small-mode ? 50% : 20%), 550px);
                Math.min(width, height)
            }

            Rectangle {
                width: thumbnail-size();
                height: self.width;
                border-radius: 4px;
                background: Bridge.audio-track-cover.width == 0 ? FCastPalette.neutral-1000 : transparent;

                if Bridge.audio-track-cover.width > 0: Image {
                    source: Bridge.audio-track-cover;
                    image-fit: contain;
                    width: parent.width;
                    height: parent.height;
                }

                if Bridge.audio-track-cover.width == 0: Image {
                    source: @image-url("./music-note.svg");
                    width: parent.width * 50%;
                    height: parent.height * 52%;
                }
            }
        }

        Rectangle {
            height: !small-mode ? 43px : 5px;
        }

        if !Bridge.media-title.is-empty: FText {
            horizontal-alignment: center;
            text: Bridge.media-title;
            font-size: 28px;
            font-weight: 600;
            color: FCastPalette.neutral-100;
        }

        if !Bridge.artist-name.is-empty: FText {
            horizontal-alignment: center;
            text: Bridge.artist-name;
            font-size: 18px;
            font-weight: 600;
            color: FCastPalette.opacity-light-500;
        }

        Rectangle {
            height: 20px;
        }

        scrubber := PositionScrubber {
            changed(_) => {
                // scrubber-changed();
            }

            released(position) => {
                Bridge.is-scrubbing-position = false;
                Bridge.seek-to-percent(position);
            }
        }

        ProgressLabels { }

        HorizontalLayout {
            alignment: center;

            MasterButton { }
        }
    }
}

component OutlinedText inherits FText {
    stroke-width: 2px;
    stroke: black;
    font-size: 22px;
    color: white;
}

component DebugOverlay inherits Rectangle {
    x: 0;
    y: 0;

    ScrollView {
        VerticalLayout {
            padding: 8px;
            spacing: 10px;

            OutlinedText {
                text: "Connected devices: " + Bridge.connected_devices //
                + "  Volume: " + Bridge.volume //
                + "  Is playing: " + (Bridge.playing ? "true" : "false") //
                + "  Playback state: " + Bridge.gui-playback-state-to-string(Bridge.playback-state) //
                + "  Progress label: " + Bridge.progress-label
                + "  Is live: " + (Bridge.is-live ? "true" : "false");
                wrap: word-wrap;
            }

            if Bridge.video-dbg.length > 0: OutlinedText {
                text: "-- Video --";
            }

            if Bridge.video-dbg.length > 0: VerticalLayout {
                for video[idx] in Bridge.video-dbg: OutlinedText {
                    text: "#" + idx //
                    + "  Codec: " + video.info.codec //
                    + "  Bitrate: " + video.bitrate //
                    + "  Max bitrate: " + video.max-bitrate //
                    + "  Resolution: " + video.width + "x" + video.height //
                    + "  Framerate: " + video.framerate-n + "/" + video.framerate-d;
                    wrap: word-wrap;
                }
            }

            if Bridge.audio-dbg.length > 0: OutlinedText {
                text: "-- Audio --";
            }

            if Bridge.audio-dbg.length > 0: VerticalLayout {
                spacing: 10px;

                for audio[idx] in Bridge.audio-dbg: OutlinedText {
                    text: "#" + idx //
                    + "  Codec: " + audio.info.codec //
                    + "  Bitrate: " + audio.bitrate //
                    + "  Max bitrate: " + audio.max-bitrate //
                    + "  Sample rate: " + audio.sample-rate //
                    + "  Channels: " + audio.channels //
                    + "  Language: " + audio.language;
                    wrap: word-wrap;
                }
            }

            if Bridge.subtitle-dbg.length > 0: OutlinedText {
                text: "-- Subtitle --";
            }

            if Bridge.subtitle-dbg.length > 0: VerticalLayout {
                spacing: 10px;

                for sub[idx] in Bridge.subtitle-dbg: OutlinedText {
                    text: "#" + idx //
                    + "  Codec: " + sub.info.codec //
                    + "  Language: " + sub.language;
                    wrap: word-wrap;
                }
            }

            Rectangle { }
        }
    }
}

export component MainWindow inherits Window {
    title: "FCast Receiver";

    default-font-family: "Outfit";
    default-font-size: 15px;
    default-font-weight: 400;

    public function playback-started() {
        Bridge.playing = true;
        // playback-control.playback-started();
    }

    public function device-connected() {
        Bridge.connected_devices += 1;
    }

    // public function device-disconnected() {
    //     Bridge.connected_devices = max(Bridge.connected_devices - 1, 0);
    // }

    public function playback-stopped-with-error(error: string) {
        Bridge.playing = false;
        error-alert.message = error;
        error-alert.show();
        // playback-control.playback-stopped();
    }

    public function update-progress-percent(percent: float) {
        // playback-control.update-progress-percent(percent);
    }

    FocusScope {
        capture-key-pressed(event) => Bridge.capture-key-pressed(event);
    }

    if Bridge.app-state == AppState.Idle: IdleView { }

    if Bridge.app-state == AppState.LoadingMedia: LoadingMediaView { }

    if Bridge.app-state == AppState.Playing && Bridge.player-variant == UiPlayerVariant.Video: VideoPlayerView { }

    if Bridge.app-state == AppState.Playing && Bridge.player-variant == UiPlayerVariant.Image: ImageView { }

    if Bridge.app-state == AppState.Playing && Bridge.player-variant == UiPlayerVariant.Audio: AudioView { }

    if Bridge.is-debugging: DebugOverlay { }

    error-alert := ErrorAlert {
        width: min(parent.width * 0.8, 700px);
        y: parent.height - self.height - 20px;
    }
}
