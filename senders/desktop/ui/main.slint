// TODO: split this big file into multiple ones

import {
    VerticalBox,
    HorizontalBox,
} from "std-widgets.slint";
import {
    Button,
    ComboBox,
    Palette,
    Spinner,
    Switch,
    TextEdit,
    Slider,
    LineEdit,
    Palette,
    FText,
    ListView,
    ScrollView,
    Icons,
} from "../../ui-components/std-widgets.slint";
import { FocusBorder } from "../../ui-components/components.slint";
import { FCastPalette } from "../../ui-components/styling.slint";
import {
    Utils,
    VideoResolutionPicker,
    FrameratePicker,
} from "../../../sdk/mirroring_core/ui/common.slint";
import "../../ui-components/fonts/Outfit-Regular.ttf";
import { CheckBox } from "../../ui-components/checkbox.slint";

export enum UiAppState {
    Disconnected,
    Connecting,
    SelectingInputType,
    SelectingMirroringSource,
    LocalMedia,
    UnsupportedReceiver,
    StartingCast,
    Mirroring,
    YtDlp,
}

export enum UiInputType {
    LocalMedia,
    Mirroring,
}

export struct UiVideoSourceModel {
    name: string,
    uid: int,
    preview: image,
}

export struct UiAudioSourceModel {
    name: string,
    uid: int,
}

export struct UiDirectoryEntry {
    id: int,
    name: string,
}

export enum UiMediaFileType {
    Audio,
    Video,
    Image,
}

export enum UiPlaybackState {
    Idle,
    Buffering,
    Playing,
    Paused,
}

export enum UiCastProtocol {
    FCast,
    GCast,
}

export struct UiMediaFileEntry {
    id: int,
    name: string,
    type: UiMediaFileType,
}

export enum UiYtDlpState {
    Fetching,
    HasDataButFetching,
    HasData,
}

export struct UiYtDlpSource {
    id: int,
    title: string,
    thumbnail: image,
}

export struct UiDevice {
    name: string,
    fcast: bool,
}

export enum UiRootDirType {
    Unknown,
    Pictures,
    Videos,
    Music,
}

export enum UiUpdaterState {
    Idle,
    Downloading,
    DownloadFailed,
    Installing,
    InstallFailed,
    InstallSuccessful,
}

export global Bridge {
    in property <string> app-version;
    in property <bool> is-audio-supported: false;
    in property <bool> is-mirroring-supported: false;
    in property <string> current-directory: "";
    in property <[UiDevice]> devices: [];
    in property <string> log-string;
    in property <bool> is-yt-dlp-available: false;
    in property <string> settings-file-path;
    in property <string> new-update-version;
    in property <int> update-download-progress;
    in property <string> updater-error-msg;
    in property <UiRootDirType> root-dir-type: UiRootDirType.Videos;

    in-out property <UiAppState> app-state: Disconnected;
    in-out property <string> device-name: "";
    in-out property <string> device-ip: "";
    in-out property <int> selected-video-src: -1;
    in-out property <int> selected-audio-src: -1;
    in-out property <[UiVideoSourceModel]> video-sources: [];
    in-out property <[UiDirectoryEntry]> directories: [];
    in-out property <[UiMediaFileEntry]> files: [];
    in-out property <float> volume: 1.0;
    in-out property <float> playback-position: 0.0;
    in-out property <UiPlaybackState> playback-state: UiPlaybackState.Idle;
    in-out property <float> track-duration: 0.0;
    in-out property <string> playback-pos-str: 0.0;
    in-out property <string> track-dur-str: 0.0;
    in-out property <float> playback-rate: 1.0;
    in-out property <int> current-local-media-id: -1;
    in-out property <UiMediaFileType> track-type;
    in-out property <UiYtDlpState> yt-dlp-state: Fetching;
    in-out property <string> yt-dlp-url;
    in-out property <[UiYtDlpSource]> yt-dlp-sources: [];
    in-out property <int> current-yt-dlp-id: -1;
    in-out property <bool> is-connecting-to-manually-inputted-device: false;
    in-out property <string> file-server-port: 0;
    in-out property <string> mirroring-server-port: 0;
    in-out property <string> mirroring-source-name;
    in-out property <bool> is-reconnecting: false;
    in-out property <UiMediaFileType> current-media-type;
    in-out property <bool> update-available: false;
    in-out property <UiUpdaterState> updater-state: UiUpdaterState.Idle;

    public function clear-mirroring-state() {
        selected-video-src = -1;
        selected-audio-src = -1;
        video-sources = [];
        playback-state = UiPlaybackState.Idle;
        playback-position = 0.0;
        track-duration = 0.0;
        mirroring-source-name = "";
    }

    public function clear-yt-dlp-state() {
        yt-dlp-state = UiYtDlpState.Fetching;
        yt-dlp-url = "";
        yt-dlp-sources = [];
        current-yt-dlp-id = -1;
    }

    public function clear-local-media-state() {
        directories = [];
        files = [];
    }

    public function change-state(new-state: UiAppState) {
        if new-state == UiAppState.Disconnected {
            device-name = "";
            device-ip = "";
            current-local-media-id = -1;
            playback-state = UiPlaybackState.Idle;
            playback-position = 0.0;
            track-duration = 0.0;
            current-media-type = UiMediaFileType.Image;
            clear-mirroring-state();
            clear-yt-dlp-state();
            clear-local-media-state();
            is-connecting-to-manually-inputted-device = false;
        }
        app-state = new-state;
    }

    public pure function is-valid-port(port: float) -> bool {
        port > 0.0 && port <= 65535.0
    }

    callback connect-to-device(string);
    callback select-input-type(input-type: UiInputType);
    callback start-cast(video_uid: int, include-audio: bool, scale-width: int, scale-height: int, max-framerate: int);
    callback stop-cast(disconnect: bool);
    callback reload-video-sources();
    callback reload-audio-sources();
    callback change-dir-parent();
    callback change-dir-child(dir-id: int);
    callback cast-local-media(file-id: int);
    callback seek(seconds: float, force-complete: bool);
    // When `state` is:
    //   - Idle -> Stop playback
    //   - Playing -> Resume playback
    //   - Paused -> Pause playback
    //   - Buffering -> Ignored
    callback change-playback-state(state: UiPlaybackState);
    callback change-volume(volume: float, force-complete: bool);
    callback disconnect();
    callback connect-manually(url: string);
    callback reload-log-string();
    callback start-test-pattern-cast();
    callback open-url(url: string);
    callback try-play-url(url: string);
    callback cast-yt-dlp(id: int);
    callback change-root-dir(new-root: UiRootDirType);
    callback change-playback-rate(rate: float);
    callback update-settings();
    callback update-application();
    callback restart-application();

    pure callback is-device-info-valid(info: string) -> bool;
    pure callback is-valid-url(url: string) -> bool;
}

component Spacer inherits Rectangle { }

component DeviceListItem {
    in property <string> dev-name;
    in property <bool> fcast;

    forward-focus: focus-scope;

    accessible-role: list-item;

    states [
        hover when i-touch-area.has-hover: {
            i-background.background: FCastPalette.brand-600.transparentize(92%);
            i-background.border-width: 1px;
            i-background.border-color: #1478DC33;
        }
    ]

    i-touch-area := TouchArea {
        clicked => {
            if Bridge.app-state == UiAppState.Connecting {
                Bridge.disconnect();
            } else {
                Bridge.device-name = dev-name;
                Bridge.connect-to-device(dev-name);
            }
        }
    }

    i-background := Rectangle {
        background: #13151B;
        border-radius: 8px;

        VerticalLayout {
            HorizontalBox {

                Image {
                    width: 36px;
                    height: 36px;
                    source: Icons.tv;
                    vertical-alignment: center;
                }

                FText {
                    text: dev-name;
                    font-size: 16px;
                    vertical-alignment: center;
                    overflow: elide;
                }

                VerticalLayout {
                    alignment: center;

                    Image {
                        width: 20px;
                        height: 20px;
                        source: fcast ? Icons.fcast-small : Icons.gcast-small;
                        vertical-alignment: center;
                    }
                }

                Spacer { }

                if Bridge.app-state == UiAppState.Connecting && !i-touch-area.has-hover && Bridge.device-name == dev-name: VerticalLayout {
                    alignment: center;

                    HorizontalBox {
                        Spinner {
                            indeterminate: true;
                        }

                        FText {
                            text: "Connecting";
                            vertical-alignment: center;
                        }
                    }
                }

                if i-touch-area.has-hover: VerticalLayout {
                    alignment: center;

                    Rectangle {
                        background: FCastPalette.bg-brand-solid;
                        border-radius: 4px;
                        border-width: 1px;
                        border-color: @linear-gradient(180deg, #FFFFFF1A 0%, #FFFFFF03 100%);
                        drop-shadow-color: #0000004D;

                        i-connect-txt := HorizontalLayout {
                            padding-top: 4px;
                            padding-bottom: 4px;
                            padding-left: 12px;
                            padding-right: 12px;
                            alignment: center;

                            FText {
                                states [
                                    connecting when Bridge.app-state == UiAppState.Connecting: {
                                        text: "Disconnect";
                                    }
                                ]
                                text: "Connect";
                            }
                        }
                    }
                }
            }
        }
    }

    focus-scope := FocusScope {
        x: 0;
        width: 0;

        key-pressed(event) => {
            if (event.text == "\n") {
                i-touch-area.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (focus-scope.has-focus): FocusBorder {
        border-radius: i-background.border-radius;
    }
}

component LabelText inherits Text {
    color: Palette.foreground;
    font-weight: 500;
    font-size: 20px;
}

component RegularText inherits Text {
    color: Palette.foreground;
    font-weight: 400;
    font-size: 16px;
}

component SecondaryText inherits Text {
    color: FCastPalette.neutral-600;
    font-weight: 300;
    font-size: 12px;
}

component Circle inherits Rectangle {
    height: self.width;
    border-width: 1.22px;
    border-radius: self.height;
    border-color: red;
}

component HyperLink inherits Rectangle {
    in property <string> url;
    in property <string> text;

    TouchArea {
        mouse-cursor: pointer;

        clicked => {
            Bridge.open-url(url);
        }
    }

    HorizontalLayout {
        spacing: 5.5px;

        SecondaryText {
            vertical-alignment: center;
            color: FCastPalette.brand-600;
            text: text;
        }

        VerticalLayout {
            alignment: center;

            Image {
                source: Icons.open-external;
                width: 9px;
                height: 9px;
            }
        }

        Spacer { }
    }
}

component DisconnectButton inherits Button {
    icon: Icons.disconnect;
    text: "Disconnect";
    text-color: FCastPalette.negative-600;
    background-default-drop-shadow-color: transparent;
    background-default-color: transparent;
    border-color: FCastPalette.negative-600.transparentize(80%);

    clicked => {
        Bridge.disconnect();
    }
}

component ReconnectingView inherits Rectangle {
    background: FCastPalette.neutral-1200;

    HorizontalLayout {
        alignment: center;

        VerticalLayout {
            alignment: center;
            spacing: 10px;

            FText {
                text: "Reconnecting to " + Bridge.device-name;
            }

            DisconnectButton {
                clicked => {
                    Bridge.is-reconnecting = false;
                    Bridge.disconnect();
                }
            }
        }
    }
}

component ConnectView inherits Rectangle {
    Rectangle {
        background: FCastPalette.neutral-1200;
        // background: FCastPalette.background-color-secondary;

        VerticalLayout {
            VerticalLayout {
                padding: 20px;

                HorizontalLayout {
                    VerticalLayout {
                        LabelText {
                            text: "Discovered receivers";
                        }

                        if Bridge.devices.length > 0: FText {
                            text: "Scanning local network (mDNS) for FCast-enabled devices...";
                            wrap: word-wrap;
                            font-size: 12px;
                            color: grey;
                        }
                    }
                }

                if Bridge.devices.length == 0: HorizontalLayout {
                    Spacer { }

                    VerticalLayout {
                        alignment: center;
                        spacing: 10px;

                        Circle {
                            width: 25%;
                            border-color: FCastPalette.border-secondary.transparentize(94%);

                            Circle {
                                width: 75%;
                                border-color: FCastPalette.border-secondary.transparentize(90%);

                                Circle {
                                    width: 70%;
                                    border-color: FCastPalette.border-secondary.transparentize(85%);

                                    Circle {
                                        width: 60%;
                                        border-color: FCastPalette.border-secondary.transparentize(80%);
                                    }
                                }
                            }
                        }

                        LabelText {
                            horizontal-alignment: center;
                            text: "No receivers found";
                        }

                        SecondaryText {
                            text: "FCast requires a Receiver App running on your target device before it appears here.";
                            horizontal-alignment: center;
                            wrap: word-wrap;
                        }
                    }

                    Spacer { }
                }

                if Bridge.devices.length > 0: ScrollView {
                    VerticalLayout {
                        padding-top: 20px;
                        spacing: 8px;
                        for device in Bridge.devices: DeviceListItem {
                            dev-name: device.name;
                            fcast: device.fcast;
                        }

                        Spacer { }
                    }
                }
            }

            property <bool> is-showing-manual-connect: false;
            // property <bool> is-showing-manual-connect: true;

            Rectangle {
                height: 1px;
                background: #FFFFFF1A;
            }

            Rectangle {
                background: FCastPalette.opacity-light-1200;

                TouchArea {
                    clicked => {
                        is-showing-manual-connect = !is-showing-manual-connect;
                    }
                }

                HorizontalBox {
                    alignment: space-between;
                    padding-top: 18px;
                    padding-right: 16px;
                    padding-bottom: 18px;
                    padding-left: 16px;

                    FText {
                        text: "Unable to see the device you're looking for? Connect via IP";
                        vertical-alignment: center;
                        wrap: word-wrap;
                    }

                    VerticalLayout {
                        alignment: center;

                        Rectangle {
                            width: 18.66px;
                            height: 18.67px;
                            border-radius: self.height;
                            background: #FFFFFF1A;

                            Image {
                                vertical-alignment: center;
                                horizontal-alignment: center;
                                width: 8.8px;
                                height: 5.1px;
                                source: Icons.arrow-down;
                                colorize: FCastPalette.neutral-500;
                            }
                        }
                    }
                }
            }

            if is-showing-manual-connect: VerticalLayout {
                padding-top: 18px;
                padding-right: 16px;
                padding-bottom: 18px;
                padding-left: 16px;

                Rectangle {
                    height: 1px;
                    background: FCastPalette.border-subtle;
                }

                HorizontalLayout {
                    padding-top: 18px;
                    padding-right: 16px;
                    padding-bottom: 18px;
                    padding-left: 16px;

                    i-left := VerticalLayout {
                        padding-right: 12px;
                        spacing: 6px;

                        HorizontalLayout {
                            spacing: 8px;

                            i-dev-info-input := LineEdit {
                                placeholder-text: "<fcast/gcast>://<ip>:<port>";

                                key-pressed(event) => {
                                    if event.text == Key.Return {
                                        connect-man-btn.clicked();
                                        return accept;
                                    }
                                    reject
                                }
                            }

                            connect-man-btn := Button {
                                enabled: Bridge.is-connecting-to-manually-inputted-device ? true : Bridge.is-device-info-valid(i-dev-info-input.text);
                                text: Bridge.is-connecting-to-manually-inputted-device ? "Cancel" : "Connect";

                                clicked => {
                                    if Bridge.is-connecting-to-manually-inputted-device {
                                        Bridge.disconnect();
                                    } else {
                                        Bridge.connect-manually(i-dev-info-input.text);
                                        Bridge.is-connecting-to-manually-inputted-device = true;
                                    }
                                }
                            }
                        }

                        SecondaryText {
                            text: "Use this for devices on different subnets or VPNs. (port 46899).";
                        }
                    }

                    Rectangle {
                        width: 1px;
                        height: Math.max(i-right.preferred-height, i-left.preferred-height);
                        background: FCastPalette.border-subtle;
                    }

                    i-right := VerticalLayout {
                        padding-left: 12px;

                        FText {
                            text: "Device not listed?";
                        }

                        SecondaryText {
                            text: "FCast requires a Receiver App running on your target device before it appears here.";
                            wrap: word-wrap;
                        }

                        HyperLink {
                            url: "https://fcast.org/";
                            text: "Get the receiver app";
                        }
                    }
                }
            }
        }
    }
}

component LabelBox inherits Rectangle {
    in property <string> label;

    background: FCastPalette.neutral-1200;
    border-width: 1px;
    border-color: #202227;
    border-radius: 4px;
    height: i-vl.preferred-height;

    i-vl := VerticalLayout {
        padding: 4px;
        padding-left: 6px;
        padding-right: 6px;

        TextInput {
            text: label;
            font-family: "Overfit Mono";
            font-size: 12px;
            font-weight: 400;
            color: FCastPalette.text-secondary;
            read-only: true;
        }
    }
}

component SourceItem inherits Rectangle {
    out property <bool> has-hover: i-touch-area.has-hover;
    in property <string> label;
    in property <string> description;
    in property <image> icon;
    in property <color> icon-bg-color;
    in property <bool> enabled: true;

    callback clicked;

    background: FCastPalette.neutral-1100;
    border-color: FCastPalette.neutral-1000;
    border-width: 1px;
    border-radius: 6px;
    preferred-width: 0px;

    states [
        hover when root.enabled && i-touch-area.has-hover: {
            border-color: FCastPalette.brand-600;
        }
        disabled when !root.enabled: {
            i-icon-bg.background: FCastPalette.neutral-600.transparentize(80%);
            i-icon.colorize: FCastPalette.neutral-600;
            root.background: FCastPalette.neutral-800.transparentize(90%);
            i-title.color: FCastPalette.neutral-600;
        }
    ]

    VerticalBox {
        padding-top: 20px;
        padding-bottom: 20px;

        HorizontalLayout {
            alignment: center;
            i-icon-bg := Rectangle {
                background: icon-bg-color;
                width: 64px;
                height: 64px;
                border-radius: self.height;

                i-icon := Image {
                    source: icon;
                }
            }
        }

        i-title := RegularText {
            horizontal-alignment: center;
            text: label;
        }

        SecondaryText {
            horizontal-alignment: center;
            wrap: word-wrap;
            text: description;

            states [
                hover when i-touch-area.has-hover: {
                    color: white;
                }
            ]
        }
    }

    i-touch-area := TouchArea {
        enabled: root.enabled;

        clicked => {
            root.clicked();
        }
    }

    i-focus-scope := FocusScope {
        x: 0;
        width: 0;
        enabled: root.enabled;

        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                i-touch-area.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (root.enabled && i-focus-scope.has-focus): FocusBorder {
        border-radius: root.border-radius;
    }
}

component ImageBackground {
    in property <length> img-width;
    in property <length> img-height;

    Image {
        width: img-width;
        height: img-height;
        source: Icons.background;
    }

    Rectangle {
        width: img-width;
        height: img-height;
        background: #0C0D12D0;
    }
}

component ReadyToCastView inherits Rectangle {
    callback show-mirroring;
    callback show-yt-dlp-view;

    ImageBackground {
        img-width: root.width;
        img-height: root.height;
    }

    Rectangle {
        VerticalLayout {
            spacing: 8px;
            padding-top: 40px;
            padding: 20px;

            SecondaryText {
                text: "CONNECTED TO";
                font-family: "Overfit Mono";
                font-size: 10px;
            }

            HorizontalLayout {
                alignment: space-between;

                LabelText {
                    font-size: 22px;
                    text: Bridge.device-name;
                }

                DisconnectButton { }
            }

            HorizontalLayout {
                LabelBox {
                    label: Bridge.device-ip;
                }

                Spacer { }
            }

            SecondaryText {
                text: "Receiver is idle. Select media to start streaming.";
                vertical-alignment: center;
            }

            if Bridge.is-yt-dlp-available: HorizontalLayout {
                spacing: 8px;

                i-line-edit-url := LineEdit {
                    placeholder-text: "Paste URL (http/https, .mp4, .m3u8)...";
                    icon: Icons.link;

                    key-pressed(event) => {
                        if event.text == Key.Return {
                            cast-url-btn.clicked();
                            return accept;
                        }
                        reject
                    }
                }

                cast-url-btn := Button {
                    width: self.preferred-width + 30px;
                    text: "Cast";
                    enabled: !i-line-edit-url.text.is-empty && Bridge.is-valid-url(i-line-edit-url.text);
                    background-default-color: FCastPalette.brand-600;

                    clicked => {
                        Bridge.clear-yt-dlp-state();
                        show-yt-dlp-view();
                        Bridge.yt-dlp-url = i-line-edit-url.text;
                        Bridge.try-play-url(i-line-edit-url.text);
                        i-line-edit-url.text = "";
                    }
                }
            }

            if !Bridge.is-yt-dlp-available: HorizontalLayout {
                spacing: 5px;

                FText {
                    text: "yt-dlp was not found.";
                    overflow: elide;
                }

                HyperLink {
                    text: "Get it here.";
                    url: "https://github.com/yt-dlp/yt-dlp/wiki/Installation";
                }

                Spacer { }
            }

            GridLayout {
                padding-top: 20px;
                spacing: 10px;

                i-cast-media-item := SourceItem {
                    label: "Cast media file";
                    description: "Cast MP4, MKV, or MP3 files directly from your hard drive with zero compression.";
                    icon: Icons.folder-fcast;
                    icon-bg-color: #2889E821;

                    clicked => {
                        Bridge.select-input-type(UiInputType.LocalMedia);
                        Bridge.app-state = UiAppState.LocalMedia;
                    }
                }

                i-mirroring-item := SourceItem {
                    label: "Mirror screen";
                    description: "Share your entire desktop. Low latency for demos and presentations.";
                    icon: Icons.mirror;
                    icon-bg-color: #7C3AED29;
                    enabled: Bridge.is-mirroring-supported;

                    clicked => {
                        Bridge.select-input-type(UiInputType.Mirroring);
                        show-mirroring();
                    }
                }

                i-test-pattern-item := SourceItem {
                    label: "Video test pattern";
                    description: "Validate display settings and network latency..";
                    icon: Icons.media-file;
                    icon-bg-color: #DB8C0E33;
                    enabled: Bridge.is-mirroring-supported;

                    clicked => {
                        Bridge.start-test-pattern-cast();
                        Bridge.mirroring-source-name = "VideoTestSource";
                        Bridge.app-state = UiAppState.Mirroring;
                    }
                }
            }

            Spacer { }
        }
    }
}

component YtDlpSourceItem inherits Rectangle {
    in property <UiYtDlpSource> source;

    callback cast-this;

    border-radius: 6px;

    states [
        playing when !ta.has-hover && Bridge.current-yt-dlp-id == source.id: {
            background: FCastPalette.brand-600.transparentize(92%);
        }
        hover when ta.has-hover: {
            background: FCastPalette.brand-600.transparentize(92%);
            border-width: 1px;
            border-color: #1478DC33;
        }
    ]

    ta := TouchArea {
        mouse-cursor: pointer;

        clicked => {
            if Bridge.current-yt-dlp-id == source.id {
                Bridge.change-playback-state(UiPlaybackState.Idle);
                Bridge.current-yt-dlp-id = -1;
            } else {
                root.cast-this();
            }
        }
    }

    HorizontalLayout {
        padding: 10px;
        spacing: 10px;

        Rectangle {
            height: 60px;
            width: 120px;

            states [
                not-found when source.thumbnail.width == 0: {
                    background: FCastPalette.neutral-600.transparentize(80%);
                    border-radius: 6px;
                    thumbnail.colorize: FCastPalette.foreground.transparentize(50%);
                }
            ]

            thumbnail := Image {
                height: 60px;
                width: 120px;

                source: source.thumbnail.width > 0 ? source.thumbnail : Icons.more;
                image-fit: ImageFit.contain;
            }
        }

        FText {
            vertical-alignment: center;
            text: source.title;
            overflow: elide;
        }

        Spacer { }

        if Bridge.current-yt-dlp-id != source.id && ta.has-hover: VerticalLayout {
            alignment: center;

            Image {
                source: Icons.play;
                width: 20px;
            }
        }

        if Bridge.current-yt-dlp-id == source.id: VerticalLayout {
            alignment: center;

            Image {
                source: Icons.stop;
                width: 20px;
            }
        }
    }

    focus-scope := FocusScope {
        x: 0;
        width: 0;

        key-pressed(event) => {
            if (event.text == Key.Return) {
                ta.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (focus-scope.has-focus): FocusBorder {
        border-radius: root.border-radius;
    }
}

component PlaybackSettingsMenuItem inherits Rectangle {
    in property <string> label;
    in property <image> icon;

    callback clicked;

    border-radius: 6px;

    states [
        hover when i-ta-playback-rate.has-hover: {
            i-playback-rate-text.color: FCastPalette.foreground;
            i-playback-rate-arrow-icon.colorize: FCastPalette.foreground;
            background: FCastPalette.brand-600;
        }
    ]

    i-ta-playback-rate := TouchArea {
        clicked => root.clicked();
    }

    HorizontalLayout {
        padding: 8px;
        padding-top: 14px;
        padding-bottom: 14px;
        spacing: 8px;

        VerticalLayout {
            alignment: center;

            Image {
                width: 16px;
                height: 16px;
                source: icon;
            }
        }

        i-playback-rate-text := FText {
            text: label;
            color: FCastPalette.neutral-500;
        }

        Spacer { }

        VerticalLayout {
            alignment: center;

            i-playback-rate-arrow-icon := Image {
                width: 4.67px;
                height: 8px;
                source: Icons.arrow-right;
            }
        }
    }
}

component PlaybackRateItem inherits Rectangle {
    in property <float> rate;
    in property <bool> selected;

    callback clicked;

    border-radius: 6px;

    states [
        selected when selected: {
            background: @linear-gradient(90.92deg, #2D7AF8 0.79%, #0757D9 104.49%);
            icon.source: Icons.check-tick;
        }
        hover when ta.has-hover: {
            background: @linear-gradient(90.92deg, #2D7AF850 0.79%, #0757D950 104.49%);
        }
    ]

    ta := TouchArea {
        mouse-cursor: pointer;

        clicked => clicked();
    }

    HorizontalLayout {
        padding: 6px;
        padding-left: 12px;
        padding-right: 12px;

        FText {
            text: rate;
        }

        Spacer { }

        VerticalLayout {
            alignment: center;

            icon := Image {
                source: Icons.arrow-right;
            }
        }
    }
}

component PlaybackControls inherits Rectangle {
    background: FCastPalette.neutral-1200;

    states [
        playing when Bridge.playback-state == UiPlaybackState.Playing: {
            i-master-button.icon: Icons.pause;
            i-master-button.enabled: true;
        }
        paused when Bridge.playback-state == UiPlaybackState.Paused: {
            i-master-button.icon: Icons.play;
            i-master-button.enabled: true;
        }
    ]

    VerticalLayout {
        alignment: center;
        padding-top: 20px;
        padding-right: 24px;
        padding-bottom: 20px;
        padding-left: 24px;

        HorizontalLayout {
            spacing: 16px;

            FText {
                text: Bridge.playback-pos-str;
                font-weight: 400;
                vertical-alignment: center;
                font-family: "Outfit Monospace";
            }

            Slider {
                hide-thumb: true;
                value <=> Bridge.playback-position;
                maximum: Bridge.track-duration;
                thumb-color: FCastPalette.foreground;

                changed(new-time) => {
                    Bridge.seek(new-time, false);
                }

                released(new-time) => {
                    Bridge.seek(new-time, true);
                }
            }

            FText {
                text: Bridge.track-dur-str;
                font-weight: 400;
                vertical-alignment: center;
                font-family: "Outfit Monospace";
            }
        }

        HorizontalLayout {
            padding-top: 12px;

            HorizontalLayout {
                spacing: 2px;

                VerticalLayout {
                    alignment: center;

                    Image {
                        source: Icons.volume-high;
                        width: 16px;
                        height: 16px;
                    }
                }

                Slider {
                    value <=> Bridge.volume;
                    maximum: 1.0;
                    minimum: 0.0;
                    step: 0.01;
                    width: 200px;
                    track-color: FCastPalette.brand-600;
                    rail-color: FCastPalette.neutral-1000;

                    changed(new-volume) => {
                        Bridge.change-volume(new-volume, false)
                    }

                    released(new-volume) => {
                        Bridge.change-volume(new-volume, true);
                    }
                }
            }

            Spacer { }

            i-master-button := Button {
                height: 40px;
                width: 40px;
                icon-size: 15px;
                enabled: false;

                clicked => {
                    Bridge.change-playback-state(
                        Bridge.playback-state == UiPlaybackState.Playing ? UiPlaybackState.Paused : UiPlaybackState.Playing);
                }
            }

            Spacer { }

            Spacer {
                width: 200px - 60px;
            }

            settings-btn := Button {
                height: 40px;
                width: 40px;
                icon: Icons.settings;
                icon-size: 18px;

                clicked => {
                    i-settings-popup.show();
                }
            }
        }
    }

    i-settings-popup := PopupWindow {
        width: settings-rect.preferred-width;
        height: settings-rect.preferred-height;

        x: settings-btn.x - self.width + settings-btn.width;
        y: settings-btn.y - self.height;
        close-policy: close-on-click-outside;

        settings-rect := Rectangle {
            background: @linear-gradient(180deg, #202022 0%, #0F0F10 100%);
            border-color: @radial-gradient(circle, rgba(255, 255, 255, 0.04) 0%, rgba(102, 102, 102, 0.04) 100%);
            border-width: 1px;
            border-radius: 6px;
            forward-focus: inner-fs;

            inner-fs := FocusScope {
                VerticalLayout {
                    padding: 10px;
                    padding-top: 15px;

                    HorizontalLayout {
                        spacing: 10px;

                        i-settings-label := LabelText {
                            text: "Playback settings";
                        }
                    }

                    VerticalLayout {
                        padding-top: 10px;
                        spacing: 5px;

                        PlaybackSettingsMenuItem {
                            label: "Playback rate";
                            icon: Icons.playback-rate;

                            clicked => {
                                i-pb-rate-popup.show();
                                i-settings-popup.close();
                            }
                        }

                        Rectangle {
                            height: 1px;
                            background: #FFFFFF0A;
                        }
                    }
                }
            }
        }
    }

    i-pb-rate-popup := PopupWindow {
        width: pb-rate-rect.preferred-width;
        height: pb-rate-rect.preferred-height;

        x: settings-btn.x - self.width + settings-btn.width;
        y: settings-btn.y - self.height;
        close-policy: close-on-click-outside;

        pb-rate-rect := Rectangle {
            background: @linear-gradient(180deg, #202022 0%, #0F0F10 100%);
            border-color: @radial-gradient(circle, rgba(255, 255, 255, 0.04) 0%, rgba(102, 102, 102, 0.04) 100%);
            border-width: 1px;
            border-radius: 6px;
            forward-focus: pb-rate-inner-fs;

            pb-rate-inner-fs := FocusScope {
                VerticalLayout {
                    padding: 10px;
                    padding-top: 15px;

                    HorizontalLayout {
                        spacing: 10px;

                        LabelText {
                            text: "Playback rate";
                            font-size: 16px;
                            vertical-alignment: center;
                        }
                    }

                    VerticalLayout {
                        padding-top: 10px;
                        spacing: 5px;

                        property <[float]> rates: [0.25, 0.5, 0.75, 1.0, 1.25, 1.50, 1.75, 2.0];

                        for rate in rates: VerticalLayout {
                            PlaybackRateItem {
                                rate: rate;
                                selected: Bridge.playback-rate == rate;

                                clicked => {
                                    Bridge.change-playback-rate(rate);
                                    Bridge.playback-rate = rate;
                                }
                            }

                            Rectangle {
                                height: 1px;
                                background: #FFFFFF0A;
                            }
                        }
                    }
                }
            }
        }
    }
}

component RoundBackButton inherits Button {
    icon: Icons.arrow-right;
    colorize-icon: true;
    icon-rotation: 180deg;
    icon-size: 10px;
    width: 36px;
    height: 36px;
}

component PlaybackFocusScope inherits FocusScope {
    width: 0; // Do not react on clicks

    capture-key-pressed(event) => {
        if Bridge.playback-state == UiPlaybackState.Paused || Bridge.playback-state == UiPlaybackState.Playing {
            if event.text == Key.Space {
                Bridge.change-playback-state(
                    Bridge.playback-state == UiPlaybackState.Playing ? UiPlaybackState.Paused : UiPlaybackState.Playing);
            } else if event.text == Key.UpArrow || event.text == "k" {
                Bridge.change-volume(Math.min(Bridge.volume + 0.05, 1.0), true);
            } else if event.text == Key.DownArrow || event.text == "j" {
                Bridge.change-volume(Math.max(Bridge.volume - 0.05, 0.0), true);
            } else if event.text == Key.LeftArrow || event.text == "h" {
                Bridge.seek(Math.max(Bridge.playback-position - 10.0, 0.0), true);
            } else if event.text == Key.RightArrow || event.text == "l" {
                Bridge.seek(Math.min(Bridge.playback-position + 10.0, Bridge.track-duration), true);
            } else {
                return reject;
            }

            return accept;
        }
        return reject;
    }
}

component YtDlpView inherits Rectangle {
    PlaybackFocusScope { }

    ImageBackground {
        img-width: root.width;
        img-height: root.height;
    }

    VerticalLayout {
        VerticalLayout {
            padding: 20px;
            spacing: 10px;

            HorizontalLayout {
                spacing: 10px;

                RoundBackButton {
                    clicked => {
                        Bridge.app-state = UiAppState.SelectingInputType;
                        Bridge.clear-yt-dlp-state();
                    }
                }

                FText {
                    text: Bridge.yt-dlp-url;
                    vertical-alignment: center;
                    overflow: elide;
                    font-size: 20px;
                }
            }

            if Bridge.yt-dlp-state == UiYtDlpState.HasData && Bridge.yt-dlp-sources.length == 0: FText {
                text: "No supported sources found in provided URL";
                horizontal-alignment: center;
            }

            if Bridge.yt-dlp-state == UiYtDlpState.HasData || Bridge.yt-dlp-state == UiYtDlpState.HasDataButFetching: ListView {
                for source in Bridge.yt-dlp-sources: HorizontalLayout {
                    padding-right: 10px;

                    YtDlpSourceItem {
                        source: source;

                        cast-this => {
                            Bridge.cast-yt-dlp(source.id);
                            Bridge.current-yt-dlp-id = source.id;
                        }
                    }
                }
            }

            if Bridge.yt-dlp-state == UiYtDlpState.Fetching || Bridge.yt-dlp-state == UiYtDlpState.HasDataButFetching: HorizontalLayout {
                alignment: center;
                spacing: 10px;

                Spacer { }

                Spinner {
                    indeterminate: true;
                }

                FText {
                    vertical-alignment: center;
                    text: "Fetching...";
                }

                Spacer { }
            }
        }

        if Bridge.playback-state == UiPlaybackState.Playing || Bridge.playback-state == UiPlaybackState.Paused: Rectangle {
            background: FCastPalette.border-subtle;
            height: 1px;
        }

        if Bridge.playback-state == UiPlaybackState.Playing || Bridge.playback-state == UiPlaybackState.Paused: PlaybackControls { }
    }
}

component MirroringView inherits Rectangle {
    ImageBackground {
        img-width: root.width;
        img-height: root.height;
    }

    HorizontalLayout {
        alignment: center;

        VerticalLayout {
            padding: 20px;
            spacing: 10px;
            alignment: center;

            HorizontalLayout {
                spacing: 5px;

                LabelText {
                    text: "Mirroring";
                }

                SecondaryText {
                    text: Bridge.mirroring-source-name;
                    font-size: 20px;
                }

                LabelText {
                    text: "to";
                }

                SecondaryText {
                    text: Bridge.device-name;
                    font-size: 20px;
                }
            }

            Button {
                text: "Stop";

                clicked => {
                    Bridge.stop-cast(false);
                    Bridge.clear-mirroring-state();
                    Bridge.app-state = UiAppState.SelectingInputType;
                }
            }
        }
    }
}

component DirButton inherits Button {
    in property <UiRootDirType> type;
    in-out property <UiRootDirType> currently-selected;

    colorize-icon: true;

    icon: type == UiRootDirType.Pictures ? Icons.img : type == UiRootDirType.Videos ? Icons.video : Icons.audio;

    text: type == UiRootDirType.Pictures ? "Pictures" : type == UiRootDirType.Videos ? "Videos" : "Music";

    states [
        selected when currently-selected == type: {
            border-color: FCastPalette.brand-600;
            border-color-hover: FCastPalette.brand-600;
        }
    ]
}

component DirEntrySkeleton inherits Rectangle {
    in property <string> label;
    in property <image> left-icon <=> folder-img.source;
    in property <image> right-icon <=> select-img.source;
    in property <angle> left-icon-rotation: 0deg;

    height: 36px;
    border-radius: 6px;

    callback clicked;

    states [
        hover when ta.has-hover: {
            background: FCastPalette.brand-600.transparentize(92%);
            border-width: 1px;
            border-color: #1478DC33;
            folder-img.colorize: FCastPalette.foreground;
            select-img.colorize: FCastPalette.foreground;
        }
    ]

    ta := TouchArea {
        mouse-cursor: pointer;

        clicked => {
            root.clicked();
        }
    }

    HorizontalLayout {
        padding-left: 10px;
        padding-right: 10px;
        spacing: 8px;

        VerticalLayout {
            alignment: center;

            folder-img := Image {
                colorize: FCastPalette.foreground.transparentize(50%);
                width: 22px;
                transform-rotation: left-icon-rotation;
            }
        }

        FText {
            text: label;
            overflow: elide;
            vertical-alignment: center;
        }

        Spacer { }

        VerticalLayout {
            alignment: center;

            select-img := Image {
                width: 8px;
                colorize: FCastPalette.foreground.transparentize(50%);
            }
        }
    }

    i-focus-scope := FocusScope {
        x: 0;
        width: 0; // Do not react on clicks

        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                ta.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (i-focus-scope.has-focus): FocusBorder {
        border-radius: 6px;
    }
}

component DirEntry inherits DirEntrySkeleton {
    in property <UiDirectoryEntry> entry;

    left-icon: Icons.folder-fcast;
    right-icon: Icons.arrow-right;
    label: entry.name;

    clicked => {
        Bridge.change-dir-child(entry.id);
        Bridge.files = [];
        Bridge.current-local-media-id = -1;
    }
}

component FileEntry inherits Rectangle {
    in property <UiMediaFileEntry> entry;

    height: 36px;
    border-radius: 6px;

    states [
        playing when !ta.has-hover && Bridge.current-local-media-id == entry.id: {
            background: FCastPalette.brand-600.transparentize(92%);
        }
        hover when ta.has-hover: {
            background: FCastPalette.brand-600.transparentize(92%);
            border-width: 1px;
            border-color: #1478DC33;
            type-img.colorize: FCastPalette.foreground;
        }
    ]

    ta := TouchArea {
        mouse-cursor: pointer;

        clicked => {
            if Bridge.current-local-media-id == entry.id {
                Bridge.change-playback-state(UiPlaybackState.Idle);
                Bridge.current-local-media-id = -1;
            } else {
                Bridge.cast-local-media(entry.id);
                Bridge.current-local-media-id = entry.id;
            }
        }
    }

    HorizontalLayout {
        padding-left: 10px;
        padding-right: 10px;
        spacing: 8px;

        VerticalLayout {
            alignment: center;

            type-img := Image {
                colorize: FCastPalette.foreground.transparentize(50%);
                width: 22px;

                states [
                    img when entry.type == UiMediaFileType.Image: {
                        source: Icons.img;
                    }
                    video when entry.type == UiMediaFileType.Video: {
                        source: Icons.video;
                    }
                    audio when entry.type == UiMediaFileType.Audio: {
                        source: Icons.audio;
                    }
                ]
            }
        }

        FText {
            text: entry.name;
            overflow: elide;
            vertical-alignment: center;
        }

        Spacer { }

        if ta.has-hover && Bridge.current-local-media-id != entry.id: VerticalLayout {
            alignment: center;

            Image {
                source: Icons.play;
                width: 14px;
            }
        }

        if Bridge.current-local-media-id == entry.id: VerticalLayout {
            alignment: center;

            Image {
                source: Icons.stop;
                width: 14px;
            }
        }
    }

    i-focus-scope := FocusScope {
        x: 0;
        width: 0; // Do not react on clicks

        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                ta.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (i-focus-scope.has-focus): FocusBorder {
        border-radius: 6px;
    }
}

component LocalMediaView inherits Rectangle {
    PlaybackFocusScope { }

    ImageBackground {
        img-width: root.width;
        img-height: root.height;
    }

    VerticalLayout {
        padding: 10px;

        HorizontalLayout {
            spacing: 10px;

            // Button {
            RoundBackButton {
            //     icon: Icons.arrow-right;
            //     colorize-icon: true;
            //     icon-rotation: 180deg;
            //     icon-size: 10px;
            //     width: 36px;

                clicked => {
                    Bridge.stop-cast(false);
                    Bridge.app-state = UiAppState.SelectingInputType;
                    Bridge.clear-local-media-state();
                }
            }

            for type in [UiRootDirType.Pictures, UiRootDirType.Videos, UiRootDirType.Music]: DirButton {
                type: type;
                currently-selected: Bridge.root-dir-type;

                clicked => {
                    Bridge.change-root-dir(type);
                    Bridge.directories = [];
                    Bridge.files = [];
                    Bridge.root-dir-type = type;
                    Bridge.current-local-media-id = -1;
                }
            }
        }

        HorizontalLayout {
            padding: 10px;
            spacing: 4px;

            VerticalLayout {
                width: 50%;

                DirEntrySkeleton {
                    left-icon: Icons.arrow-turn-up;
                    left-icon-rotation: 270deg;
                    label: "Parent";

                    clicked => {
                        Bridge.change-dir-parent();
                        Bridge.files = [];
                        Bridge.current-local-media-id = -1;
                    }
                }

                ListView {
                    for dir in Bridge.directories: HorizontalLayout {
                        // Make scroll bar not overlap
                        padding-right: 8px;

                        DirEntry {
                            entry: dir;
                        }
                    }
                }
            }

            Rectangle {
                width: 1px;
                background: FCastPalette.border-subtle;
            }

            if Bridge.files.length > 0: ListView {
                for file in Bridge.files: HorizontalLayout {
                    padding-right: 8px;

                    FileEntry {
                        entry: file;
                    }
                }
            }

            if Bridge.files.length == 0: VerticalLayout {
                alignment: center;
                width: 50%;

                Spacer { }

                FText {
                    text: "No compatible files found";
                    wrap: word-wrap;
                    horizontal-alignment: center;
                }

                Spacer { }
            }
        }

        if (Bridge.playback-state == UiPlaybackState.Playing || Bridge.playback-state == UiPlaybackState.Paused) && Bridge.current-media-type != UiMediaFileType.Image: PlaybackControls {
            background: transparent;
        }
    }
}

component FCastPopupWindow inherits Rectangle {
    in property <string> title;

    callback close;

    background: FCastPalette.neutral-1200;
    border-color: FCastPalette.border-subtle;
    border-width: 1px;
    border-radius: 6px;

    FocusScope {
        capture-key-pressed(key) => {
            if key.text == Key.Escape {
                close();
                accept
            } else {
                reject
            }
        }
    }

    VerticalLayout {
        padding: 24px;

        HorizontalLayout {
            alignment: space-between;

            LabelText {
                text: title;
            }

            Button {
                width: 36px;
                height: 36px;
                icon: Icons.close;
                icon-size: 13.33px;
                clicked => close();
            }
        }

        @children
    }
}

component VideoSourceItem inherits Rectangle {
    in property <int> id;
    in property <image> preview;
    in property <string> name;

    border-width: 1px;
    border-color: Bridge.selected-video-src == id ? FCastPalette.brand-600 : FCastPalette.border-subtle;
    border-radius: 6px;
    background: FCastPalette.neutral-1200;

    states [
        hover when i-touch-area.has-hover: {
            background: FCastPalette.neutral-1100;
        }
    ]

    VerticalLayout {
        padding: 15px;
        spacing: 10px;

        Rectangle {
            border-radius: 6px;
            clip: true;

            Image {
                width: 100%;
                height: 100%;
                image-fit: contain;
                source: preview;
            }
        }

        LabelText {
            text: name;
            font-size: 14px;
        }
    }

    i-touch-area := TouchArea {
        clicked => {
            if Bridge.selected-video-src == id {
                Bridge.selected-video-src = -1;
            } else {
                Bridge.selected-video-src = id;
            }
        }
    }

    i-focus-scope := FocusScope {
        x: 0;
        width: 0; // Do not react on clicks

        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                i-touch-area.clicked();
                return accept;
            }
            return reject;
        }
    }

    if (i-focus-scope.has-focus): FocusBorder {
        border-radius: 6px;
    }
}

component MirroringPopup inherits FCastPopupWindow {
    title: "Mirror screen";

    property <length> spacing: 20px;
    property <int> n-columns: compute-columns(i-vl.width);

    callback hide;

    pure function compute-columns(width: length) -> int {
        if width > 1300px {
            4
        } else if width > 800px {
            3
        } else if width > 500px {
            2
        } else {
            1
        }
    }

    pure function compute-width(idx: int, root-width: length) -> length {
        (root-width - spacing) / n-columns
    }

    pure function compute-x(idx: int, width: length) -> length {
        let col = Math.mod(idx, n-columns);
        let offset = spacing * col;
        offset + col * width;
    }

    pure function compute-y(idx: int, root-width: length) -> length {
        let row = Math.floor(idx / n-columns);
        let height = 250px;
        let offset = spacing * row;
        offset + row * height
    }

    property <int> y-items: Math.ceil(Bridge.video-sources.length / n-columns);
    property <int> video-resolution-idx: 2;
    property <int> video-framerate-idx: 2;

    i-vl := VerticalLayout {
        padding-top: 24px;
        spacing: 10px;

        ScrollView {
            viewport-height: (250px + spacing) * y-items;

            for src[idx] in Bridge.video-sources: VideoSourceItem {
                x: compute-x(idx, compute-width(idx, parent.visible-width - spacing * (n-columns - 1)));
                width: compute-width(idx, parent.visible-width - spacing);
                y: compute-y(idx, parent.height);
                height: 250px;
                id: src.uid;
                preview: src.preview;
                name: src.name;
            }
        }

        Rectangle {
            height: 1px;
            background: FCastPalette.border-subtle;
        }

        if Bridge.selected-video-src != -1: HorizontalLayout {
            spacing: 8px;

            FText {
                vertical-alignment: center;
                text: "Resolution";
            }

            VideoResolutionPicker {
                current-index <=> video-resolution-idx;
            }

            FText {
                vertical-alignment: center;
                text: "Framerate";
            }

            FrameratePicker {
                current-index <=> video-framerate-idx;
            }
        }

        property <bool> include-audio: false;

        if Bridge.is-audio-supported: CheckBox {
            checked <=> include-audio;
            text: "Share system audio";
        }

        if Bridge.is-audio-supported: SecondaryText {
            text: "Captures desktop output sounds";
        }

        HorizontalLayout {
            Spacer { }

            Button {
                enabled: include-audio || Bridge.selected-video-src != -1;
                text: "Start Casting";
                background-default-color: FCastPalette.brand-600;

                clicked => {
                    let scale = Utils.str-to-scale(video-resolution-idx);
                    Bridge.start-cast(
                        Bridge.selected-video-src,
                        include-audio,
                        scale.width,
                        scale.height,
                        Utils.video-framerates[video-framerate-idx].to-float(),
                    );
                    Bridge.app-state = UiAppState.Mirroring;
                    Bridge.mirroring-source-name = Bridge.video-sources[Bridge.selected-video-src].name;
                    root.hide();
                }
            }
        }
    }
}

component SideBarEntry inherits Rectangle {
    in property <image> icon <=> i-icon.source;
    in property <string> text <=> i-text.text;

    callback clicked;

    i-ta := TouchArea {
        clicked => clicked();
    }

    HorizontalLayout {
        padding-top: 7px;
        padding-bottom: 7px;
        spacing: 10px;

        VerticalLayout {
            alignment: center;

            i-icon := Image {
                width: 12px;
                height: 12px;
                colorize: FCastPalette.neutral-600;

                states [
                    hover when i-ta.has-hover: {
                        colorize: FCastPalette.brand-600;
                    }
                ]
            }
        }

        i-text := FText {
            font-weight: 500;
            font-size: 14px;
            color: FCastPalette.neutral-600;

            states [
                hover when i-ta.has-hover: {
                    color: FCastPalette.brand-600;
                }
            ]
        }
    }
}

component SettingsEntry inherits Rectangle {
    in property <string> name;

    HorizontalLayout {
        spacing: 10px;

        FText {
            text: name;
            vertical-alignment: center;
        }

        Spacer { }

        @children
    }
}

export component MainWindow inherits Window {
    title: "FCast Sender";
    icon: @image-url("../../extra/fcast.png");

    preferred-width: 800px;
    preferred-height: 500px;

    default-font-family: "Outfit";
    default-font-size: 15px;
    default-font-weight: 400;

    background: FCastPalette.background-color-primary;
    property <bool> is-showing-mirroring-popup: false;
    property <bool> is-showing-log-popup: false;
    property <bool> is-showing-settings-popup: false;
    property <bool> is-showing-about-popup: false;

    HorizontalLayout {
        Rectangle {
            width: 230px;
            // TODO: animate hiding and showing of this drawer
            // preferred-width: root.width > 700px ? 266px : 0px;
            background: FCastPalette.neutral-1100;
            border-width: 1px;
            border-color: FCastPalette.border-subtle;

            // animate width { duration: 50ms; }

            VerticalLayout {
                padding: 20px;
                spacing: 5px;

                Image {
                    source: Icons.fcast;
                    width: 48px;
                }

                HorizontalLayout {
                    padding-top: 20px;
                    spacing: 5px;

                    FText {
                        text: "FCast Sender";
                        font-size: 20px;
                        font-weight: 900;
                        vertical-alignment: center;
                    }

                    SecondaryText {
                        vertical-alignment: center;
                        text: "BETA";
                    }
                }

                if Bridge.update-available: VerticalLayout {
                    spacing: 5px;

                    FText {
                        text: "Version " + Bridge.new-update-version + " is available";
                        wrap: word-wrap;
                    }

                    FText {
                        text: "Do you want to upgrade to the latest version?";
                        wrap: word-wrap;
                    }

                    HorizontalLayout {
                        spacing: 5px;

                        Button {
                            text: "No";

                            clicked => {
                                Bridge.update-available = false;
                            }
                        }

                        Button {
                            text: "Yes";

                            clicked => {
                                Bridge.update-application();
                                Bridge.update-available = false;
                                Bridge.updater-state = UiUpdaterState.Downloading;
                            }
                        }
                    }
                }

                Spacer { }

                Rectangle {
                    background: FCastPalette.neutral-1100;
                    height: 1px;
                }

                SideBarEntry {
                    icon: Icons.settings;
                    text: "Settings";

                    clicked => {
                        is-showing-settings-popup = true;
                    }
                }

                SideBarEntry {
                    icon: Icons.info;
                    text: "About";

                    clicked => {
                        is-showing-about-popup = true;
                    }
                }

                SideBarEntry {
                    icon: Icons.dev-log;
                    text: "Developer log";

                    clicked => {
                        Bridge.reload-log-string();
                        is-showing-log-popup = true;
                    }
                }
            }
        }

        if Bridge.is-reconnecting: ReconnectingView { }

        if !Bridge.is-reconnecting && (Bridge.app-state == UiAppState.Disconnected || Bridge.app-state == UiAppState.Connecting): ConnectView { }

        if !Bridge.is-reconnecting && Bridge.app-state == UiAppState.SelectingInputType: ReadyToCastView {
            show-mirroring => {
                is-showing-mirroring-popup = true;
            }

            show-yt-dlp-view => {
                Bridge.app-state = UiAppState.YtDlp;
            }
        }

        if !Bridge.is-reconnecting && Bridge.app-state == UiAppState.YtDlp: YtDlpView { }

        if !Bridge.is-reconnecting && Bridge.app-state == UiAppState.SelectingMirroringSource: Rectangle { }

        if !Bridge.is-reconnecting && (Bridge.app-state == UiAppState.StartingCast || Bridge.app-state == UiAppState.Mirroring): MirroringView { }

        if !Bridge.is-reconnecting && Bridge.app-state == UiAppState.LocalMedia: LocalMediaView { }
    }

    function close-mirroring-popup() {
        is-showing-mirroring-popup = false;
        Bridge.stop-cast(false);
        Bridge.clear-mirroring-state();
        Bridge.app-state = UiAppState.SelectingInputType;
    }

    function close-settings-popup() {
        Bridge.update-settings();
        is-showing-settings-popup = false;
    }

    function close-about-popup() {
        is-showing-about-popup = false;
    }

    function close-log-popup() {
        is-showing-log-popup = false;
        Bridge.log-string = "";
    }

    function close-updater-popup() {
        Bridge.updater-state = UiUpdaterState.Idle;
        // TODO: stop the updater
    }

    if is-showing-mirroring-popup || is-showing-settings-popup || is-showing-about-popup || is-showing-log-popup || Bridge.updater-state != UiUpdaterState.Idle: Rectangle {
        background: #0000009C;
        TouchArea {
            clicked => {
                if is-showing-mirroring-popup {
                    close-mirroring-popup();
                } else if is-showing-settings-popup {
                    close-settings-popup();
                } else if is-showing-about-popup {
                    close-about-popup();
                } else if is-showing-log-popup {
                    close-log-popup();
                } else if Bridge.updater-state != UiUpdaterState.Idle {
                    close-updater-popup();
                }
            }
        }
    }

    if is-showing-mirroring-popup: MirroringPopup {
        width: root.width * 75%;
        height: root.height * 85%;

        close => close-mirroring-popup();

        hide => {
            is-showing-mirroring-popup = false;
        }
    }

    if is-showing-settings-popup: FCastPopupWindow {
        width: root.width * 75%;
        height: root.height * 85%;
        title: "Settings";

        close => close-settings-popup();

        VerticalLayout {
            padding-top: 24px;

            HorizontalLayout {
                spacing: 10px;

                FText {
                    text: "The settings file is located at";
                    vertical-alignment: center;
                    overflow: elide;
                }

                LabelBox {
                    label: Bridge.settings-file-path;
                }

                Spacer { }
            }

            // TODO: Deduplicate settings entry related boilerplate etc.

            SettingsEntry {
                height: 36px;

                name: "File server port";

                if (file-server-port-input.text.to-float() > 0 && file-server-port-input.text.to-float() < 1024) || file-server-port-input.text.to-float() > 65535: FText {
                    text: "Invalid port number (must be 1024-65535)";
                    vertical-alignment: center;
                    color: FCastPalette.negative-600;
                    overflow: elide;
                }

                if file-server-port-input.text.to-float() == 0: FText {
                    text: "Automatic";
                    vertical-alignment: center;
                    overflow: elide;
                }

                file-server-port-input := LineEdit {
                    width: 100px;
                    text <=> Bridge.file-server-port;
                    input-type: number;
                }
            }

            SettingsEntry {
                height: 36px;

                name: "Mirroring server port";

                if (mirroring-server-port-input.text.to-float() > 0 && mirroring-server-port-input.text.to-float() < 1024) || mirroring-server-port-input.text.to-float() > 65535: FText {
                    text: "Invalid port number (must be 1024-65535)";
                    vertical-alignment: center;
                    color: FCastPalette.negative-600;
                    overflow: elide;
                }

                if mirroring-server-port-input.text.to-float() == 0: FText {
                    text: "Automatic";
                    vertical-alignment: center;
                    overflow: elide;
                }

                mirroring-server-port-input := LineEdit {
                    width: 100px;
                    text <=> Bridge.mirroring-server-port;
                    input-type: number;
                }
            }
        }
    }

    if is-showing-about-popup: FCastPopupWindow {
        width: root.width * 50%;
        height: root.height * 75%;
        title: "About";

        close => close-about-popup();

        VerticalLayout {
            spacing: 10px;

            FText {
                text: "FCast Sender v" + Bridge.app-version;
                horizontal-alignment: center;
            }

            HorizontalLayout {
                alignment: center;

                HyperLink {
                    url: "https://fcast.org";
                    text: self.url;
                }
            }

            FText {
                text: "Please report any issues to";
                horizontal-alignment: center;
            }

            HorizontalLayout {
                alignment: center;

                HyperLink {
                    url: "https://github.com/futo-org/fcast/issues";
                    text: "our issue tracker";
                }
            }

            Spacer { }

            SecondaryText {
                text: "This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.";
                wrap: word-wrap;
                horizontal-alignment: center;
                max-width: 400px;
            }

            SecondaryText {
                text: "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.";
                wrap: word-wrap;
                horizontal-alignment: center;
                max-width: 400px;
            }

            SecondaryText {
                horizontal-alignment: center;
                text: "Copyright  2026 FUTO";
            }
        }
    }

    if is-showing-log-popup: FCastPopupWindow {
        width: root.width * 95%;
        height: root.height * 95%;
        title: "Developer Log";

        close => close-log-popup();

        VerticalLayout {
            padding-top: 24px;
            spacing: 10px;

            Button {
                text: "Copy to clipboard";
                icon: Icons.clipboard;
                colorize-icon: true;

                clicked => {
                    log-te.select-all();
                    log-te.copy();
                    log-te.clear-selection();
                }
            }

            log-te := TextEdit {
                text: Bridge.log-string;
                read-only: true;
                enabled: false;
            }
        }
    }

    if Bridge.updater-state != UiUpdaterState.Idle: FCastPopupWindow {
        width: root.width * 75%;
        height: root.height * 75%;
        title: "Updater";

        close => close-updater-popup();

        VerticalLayout {
            padding-top: 24px;
            spacing: 10px;

            if Bridge.updater-state == UiUpdaterState.Downloading: VerticalLayout {
                spacing: 10px;

                FText {
                    text: "Downloading update...";
                    horizontal-alignment: center;
                }

                SecondaryText {
                    text: Bridge.update-download-progress + "%";
                    horizontal-alignment: center;
                }
            }

            if Bridge.updater-state == UiUpdaterState.DownloadFailed: VerticalLayout {
                spacing: 10px;

                FText {
                    text: "Download failed";
                    horizontal-alignment: center;
                }

                SecondaryText {
                    text: Bridge.updater-error-msg;
                    horizontal-alignment: center;
                    wrap: word-wrap;
                }
            }

            if Bridge.updater-state == UiUpdaterState.Installing: FText {
                text: "Installing...";
                horizontal-alignment: center;
            }

            if Bridge.updater-state == UiUpdaterState.InstallFailed: VerticalLayout {
                spacing: 10px;

                FText {
                    text: "Install failed";
                    horizontal-alignment: center;
                }

                SecondaryText {
                    text: Bridge.updater-error-msg;
                    horizontal-alignment: center;
                    wrap: word-wrap;
                }
            }

            if Bridge.updater-state == UiUpdaterState.InstallSuccessful: VerticalLayout {
                spacing: 10px;

                FText {
                    text: "Succesfully updated";
                    horizontal-alignment: center;
                }

                Button {
                    text: "Relaunch now";

                    clicked => Bridge.restart-application();
                }
            }

            if Bridge.updater-state == UiUpdaterState.DownloadFailed || Bridge.updater-state == UiUpdaterState.InstallFailed: HorizontalLayout {
                alignment: center;

                HyperLink {
                    text: "Download and install the update manually";
                    url: "https://fcast.org";
                }
            }

            Spacer { }
        }
    }
}

export component CrashWindow inherits Window {
    title: "FCast Sender Crash Reporter";

    preferred-width: 800px;
    preferred-height: 500px;

    default-font-family: "Outfit";
    default-font-size: 15px;
    default-font-weight: 400;

    background: FCastPalette.background-color-primary;

    in property <string> log: "";

    VerticalBox {
        FText {
            font-weight: 600;
            font-size: 18px;
            horizontal-alignment: center;
            vertical-alignment: center;
            wrap: word-wrap;
            text: "FCast Sender encountered an error!";
        }

        HorizontalLayout {
            alignment: center;

            spacing: 5px;

            FText {
                font-size: 18px;
                horizontal-alignment: center;
                vertical-alignment: center;
                wrap: word-wrap;
                text: "Please report your issue including the log below to:";
            }

            HyperLink {
                text: "https://github.com/futo-org/fcast/issues";
                url: "https://github.com/futo-org/fcast/issues";
            }
        }

        Button {
            text: "Copy to clipboard";
            icon: Icons.clipboard;
            colorize-icon: true;

            clicked => {
                log-te.select-all();
                log-te.copy();
                log-te.clear-selection();
            }
        }

        log-te := TextEdit {
            text: log;
            read-only: true;
            enabled: false;
        }
    }
}
