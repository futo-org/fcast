{
  "items": [
    {
      "meta": {
        "namespace": "crate",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [macro_use] extern crate std ;"
    },
    {
      "meta": {
        "namespace": "crate",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [prelude_import] use std :: prelude :: rust_2021 :: * ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "use std :: collections :: HashMap ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "use std :: sync :: Arc ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "pub use fcast_sender_sdk :: IpAddr ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "use fcast_sender_sdk :: context ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "pub use fcast_sender_sdk :: device :: { self , ApplicationInfo , CastingDeviceError , DeviceConnectionState , DeviceFeature , DeviceInfo , GenericEventSubscriptionGroup , GenericKeyEvent , GenericMediaEvent , LoadRequest , Metadata , PlaybackState , PlaylistItem , ProtocolType , Source , } ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "use flutter_rust_bridge :: frb ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (IpAddr))] pub enum _IpAddr { V4 { o1 : u8 , o2 : u8 , o3 : u8 , o4 : u8 , } , V6 { o1 : u8 , o2 : u8 , o3 : u8 , o4 : u8 , o5 : u8 , o6 : u8 , o7 : u8 , o8 : u8 , o9 : u8 , o10 : u8 , o11 : u8 , o12 : u8 , o13 : u8 , o14 : u8 , o15 : u8 , o16 : u8 , scope_id : u32 , } , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (ProtocolType))] pub enum _ProtocolType { Chromecast , FCast , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (DeviceConnectionState))] pub enum _DeviceConnectionState { Disconnected , Connecting , Connected { used_remote_addr : _IpAddr , local_addr : _IpAddr , } , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (DeviceInfo))] pub struct _DeviceInfo { pub name : String , pub protocol : ProtocolType , pub addresses : Vec < IpAddr > , pub port : u16 , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "pub fn device_info_from_url (url : String) -> Option < DeviceInfo > { device :: device_info_from_url (url) }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (PlaybackState))] pub enum _PlaybackState { # [default] Idle , Buffering , Playing , Paused , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: default :: Default for _PlaybackState { # [inline] fn default () -> _PlaybackState { Self :: Idle } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (Source))] pub enum _Source { Url { url : String , # [doc = \" MIME content type\"] content_type : String , } , Content { content : String , } , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (PlaylistItem))] pub struct _PlaylistItem { # [doc = \" MIME type\"] pub content_type : String , # [doc = \" URL\"] pub content_location : String , # [doc = \" Seconds from beginning of media to start playback\"] pub start_time : Option < f64 > , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (GenericEventSubscriptionGroup))] pub enum _GenericEventSubscriptionGroup { Keys , Media , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (GenericKeyEvent))] pub struct _GenericKeyEvent { pub released : bool , pub repeat : bool , pub handled : bool , pub name : String , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (GenericMediaEvent))] pub enum _GenericMediaEvent { Started , Ended , Changed , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "pub trait DeviceEventHandler : Send + Sync { fn connection_state_changed (& self , state : _DeviceConnectionState) ; fn volume_changed (& self , volume : f64) ; fn time_changed (& self , time : f64) ; fn playback_state_changed (& self , state : _PlaybackState) ; fn duration_changed (& self , duration : f64) ; fn speed_changed (& self , speed : f64) ; fn source_changed (& self , source : _Source) ; fn key_event (& self , event : _GenericKeyEvent) ; fn media_event (& self , event : _GenericMediaEvent) ; fn playback_error (& self , message : String) ; }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (ignore)] struct DeviceEventHandlerWrapper (Arc < dyn DeviceEventHandler >) ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "impl device :: DeviceEventHandler for DeviceEventHandlerWrapper { fn connection_state_changed (& self , state : DeviceConnectionState) { # [rustfmt :: skip] macro_rules ! ip_addr_wrapper_to_orig { ($ addr : expr) => { match $ addr { IpAddr :: V4 { o1 , o2 , o3 , o4 } => _IpAddr :: V4 { o1 , o2 , o3 , o4 } , IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id , } => _IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id , } , } } ; } self . 0 . connection_state_changed (match state { DeviceConnectionState :: Disconnected => _DeviceConnectionState :: Disconnected , DeviceConnectionState :: Connecting => _DeviceConnectionState :: Connecting , DeviceConnectionState :: Connected { used_remote_addr , local_addr } => _DeviceConnectionState :: Connected { used_remote_addr : match used_remote_addr { IpAddr :: V4 { o1 , o2 , o3 , o4 } => _IpAddr :: V4 { o1 , o2 , o3 , o4 } , IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id } => _IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id , } , } , local_addr : match local_addr { IpAddr :: V4 { o1 , o2 , o3 , o4 } => _IpAddr :: V4 { o1 , o2 , o3 , o4 } , IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id } => _IpAddr :: V6 { o1 , o2 , o3 , o4 , o5 , o6 , o7 , o8 , o9 , o10 , o11 , o12 , o13 , o14 , o15 , o16 , scope_id , } , } , } , }) ; } fn volume_changed (& self , volume : f64) { self . 0 . volume_changed (volume) ; } fn time_changed (& self , time : f64) { self . 0 . time_changed (time) ; } fn playback_state_changed (& self , state : PlaybackState) { self . 0 . playback_state_changed (match state { PlaybackState :: Idle => _PlaybackState :: Idle , PlaybackState :: Buffering => _PlaybackState :: Buffering , PlaybackState :: Playing => _PlaybackState :: Playing , PlaybackState :: Paused => _PlaybackState :: Paused , }) ; } fn duration_changed (& self , duration : f64) { self . 0 . duration_changed (duration) ; } fn speed_changed (& self , speed : f64) { self . 0 . speed_changed (speed) ; } fn source_changed (& self , source : Source) { self . 0 . source_changed (match source { Source :: Url { url , content_type } => _Source :: Url { url , content_type } , Source :: Content { content } => _Source :: Content { content } , }) ; } fn key_event (& self , event : GenericKeyEvent) { self . 0 . key_event (_GenericKeyEvent { released : event . released , repeat : event . repeat , handled : event . handled , name : event . name , }) ; } fn media_event (& self , event : GenericMediaEvent) { self . 0 . media_event (match event { GenericMediaEvent :: Started => _GenericMediaEvent :: Started , GenericMediaEvent :: Ended => _GenericMediaEvent :: Ended , GenericMediaEvent :: Changed => _GenericMediaEvent :: Changed , }) ; } fn playback_error (& self , message : String) { self . 0 . playback_error (message) ; } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (CastingDeviceError))] pub enum _CastingDeviceError { # [error (\"failed to send command to worker thread\")] FailedToSendCommand , # [error (\"missing addresses\")] MissingAddresses , # [error (\"device already started\")] DeviceAlreadyStarted , # [error (\"unsupported subscription\")] UnsupportedSubscription , # [error (\"unsupported feature\")] UnsupportedFeature , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [allow (unused_qualifications)] # [automatically_derived] impl :: thiserror :: __private :: Error for _CastingDeviceError { }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [allow (unused_qualifications)] # [automatically_derived] impl :: core :: fmt :: Display for _CastingDeviceError { fn fmt (& self , __formatter : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { # [allow (unused_variables , deprecated , clippy :: used_underscore_binding)] match self { _CastingDeviceError :: FailedToSendCommand { } => __formatter . write_str (\"failed to send command to worker thread\") , _CastingDeviceError :: MissingAddresses { } => __formatter . write_str (\"missing addresses\") , _CastingDeviceError :: DeviceAlreadyStarted { } => __formatter . write_str (\"device already started\") , _CastingDeviceError :: UnsupportedSubscription { } => __formatter . write_str (\"unsupported subscription\") , _CastingDeviceError :: UnsupportedFeature { } => __formatter . write_str (\"unsupported feature\") , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for _CastingDeviceError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { _CastingDeviceError :: FailedToSendCommand => \"FailedToSendCommand\" , _CastingDeviceError :: MissingAddresses => \"MissingAddresses\" , _CastingDeviceError :: DeviceAlreadyStarted => \"DeviceAlreadyStarted\" , _CastingDeviceError :: UnsupportedSubscription => \"UnsupportedSubscription\" , _CastingDeviceError :: UnsupportedFeature => \"UnsupportedFeature\" , }) } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (DeviceFeature))] pub enum _DeviceFeature { SetVolume , SetSpeed , LoadContent , LoadUrl , KeyEventSubscription , MediaEventSubscription , LoadImage , LoadPlaylist , PlaylistNextAndPrevious , SetPlaylistItemIndex , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: clone :: Clone for _DeviceFeature { # [inline] fn clone (& self) -> _DeviceFeature { match self { _DeviceFeature :: SetVolume => _DeviceFeature :: SetVolume , _DeviceFeature :: SetSpeed => _DeviceFeature :: SetSpeed , _DeviceFeature :: LoadContent => _DeviceFeature :: LoadContent , _DeviceFeature :: LoadUrl => _DeviceFeature :: LoadUrl , _DeviceFeature :: KeyEventSubscription => _DeviceFeature :: KeyEventSubscription , _DeviceFeature :: MediaEventSubscription => _DeviceFeature :: MediaEventSubscription , _DeviceFeature :: LoadImage => _DeviceFeature :: LoadImage , _DeviceFeature :: LoadPlaylist => _DeviceFeature :: LoadPlaylist , _DeviceFeature :: PlaylistNextAndPrevious => _DeviceFeature :: PlaylistNextAndPrevious , _DeviceFeature :: SetPlaylistItemIndex => _DeviceFeature :: SetPlaylistItemIndex , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for _DeviceFeature { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { _DeviceFeature :: SetVolume => \"SetVolume\" , _DeviceFeature :: SetSpeed => \"SetSpeed\" , _DeviceFeature :: LoadContent => \"LoadContent\" , _DeviceFeature :: LoadUrl => \"LoadUrl\" , _DeviceFeature :: KeyEventSubscription => \"KeyEventSubscription\" , _DeviceFeature :: MediaEventSubscription => \"MediaEventSubscription\" , _DeviceFeature :: LoadImage => \"LoadImage\" , _DeviceFeature :: LoadPlaylist => \"LoadPlaylist\" , _DeviceFeature :: PlaylistNextAndPrevious => \"PlaylistNextAndPrevious\" , _DeviceFeature :: SetPlaylistItemIndex => \"SetPlaylistItemIndex\" , }) } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: marker :: StructuralPartialEq for _DeviceFeature { }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: cmp :: PartialEq for _DeviceFeature { # [inline] fn eq (& self , other : & _DeviceFeature) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: cmp :: Eq for _DeviceFeature { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "macro_rules ! device_error_converter { ($ result : expr) => { match $ result { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } ; }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (Metadata))] pub struct _Metadata { pub title : Option < String > , pub thumbnail_url : Option < String > , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for _Metadata { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , \"_Metadata\" , \"title\" , & self . title , \"thumbnail_url\" , & & self . thumbnail_url) } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: clone :: Clone for _Metadata { # [inline] fn clone (& self) -> _Metadata { _Metadata { title : :: core :: clone :: Clone :: clone (& self . title) , thumbnail_url : :: core :: clone :: Clone :: clone (& self . thumbnail_url) , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: marker :: StructuralPartialEq for _Metadata { }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: cmp :: PartialEq for _Metadata { # [inline] fn eq (& self , other : & _Metadata) -> bool { self . title == other . title && self . thumbnail_url == other . thumbnail_url } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (ApplicationInfo))] pub struct _ApplicationInfo { pub name : String , pub version : String , pub display_name : String , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for _ApplicationInfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , \"_ApplicationInfo\" , \"name\" , & self . name , \"version\" , & self . version , \"display_name\" , & & self . display_name) } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (mirror (LoadRequest))] pub enum _LoadRequest { Url { content_type : String , url : String , resume_position : Option < f64 > , speed : Option < f64 > , volume : Option < f64 > , metadata : Option < _Metadata > , request_headers : Option < HashMap < String , String > > , } , Content { content_type : String , content : String , resume_position : f64 , speed : Option < f64 > , volume : Option < f64 > , metadata : Option < _Metadata > , request_headers : Option < HashMap < String , String > > , } , Video { content_type : String , url : String , resume_position : f64 , speed : Option < f64 > , volume : Option < f64 > , metadata : Option < _Metadata > , request_headers : Option < HashMap < String , String > > , } , Image { content_type : String , url : String , metadata : Option < _Metadata > , request_headers : Option < HashMap < String , String > > , } , Playlist { items : Vec < PlaylistItem > , } , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for _LoadRequest { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { _LoadRequest :: Url { content_type : __self_0 , url : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => { let names : & 'static _ = & [\"content_type\" , \"url\" , \"resume_position\" , \"speed\" , \"volume\" , \"metadata\" , \"request_headers\"] ; let values : & [& dyn :: core :: fmt :: Debug] = & [__self_0 , __self_1 , __self_2 , __self_3 , __self_4 , __self_5 , & __self_6] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , \"Url\" , names , values) } _LoadRequest :: Content { content_type : __self_0 , content : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => { let names : & 'static _ = & [\"content_type\" , \"content\" , \"resume_position\" , \"speed\" , \"volume\" , \"metadata\" , \"request_headers\"] ; let values : & [& dyn :: core :: fmt :: Debug] = & [__self_0 , __self_1 , __self_2 , __self_3 , __self_4 , __self_5 , & __self_6] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , \"Content\" , names , values) } _LoadRequest :: Video { content_type : __self_0 , url : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => { let names : & 'static _ = & [\"content_type\" , \"url\" , \"resume_position\" , \"speed\" , \"volume\" , \"metadata\" , \"request_headers\"] ; let values : & [& dyn :: core :: fmt :: Debug] = & [__self_0 , __self_1 , __self_2 , __self_3 , __self_4 , __self_5 , & __self_6] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , \"Video\" , names , values) } _LoadRequest :: Image { content_type : __self_0 , url : __self_1 , metadata : __self_2 , request_headers : __self_3 } => :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , \"Image\" , \"content_type\" , __self_0 , \"url\" , __self_1 , \"metadata\" , __self_2 , \"request_headers\" , & __self_3) , _LoadRequest :: Playlist { items : __self_0 } => :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , \"Playlist\" , \"items\" , & __self_0) , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: clone :: Clone for _LoadRequest { # [inline] fn clone (& self) -> _LoadRequest { match self { _LoadRequest :: Url { content_type : __self_0 , url : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => _LoadRequest :: Url { content_type : :: core :: clone :: Clone :: clone (__self_0) , url : :: core :: clone :: Clone :: clone (__self_1) , resume_position : :: core :: clone :: Clone :: clone (__self_2) , speed : :: core :: clone :: Clone :: clone (__self_3) , volume : :: core :: clone :: Clone :: clone (__self_4) , metadata : :: core :: clone :: Clone :: clone (__self_5) , request_headers : :: core :: clone :: Clone :: clone (__self_6) , } , _LoadRequest :: Content { content_type : __self_0 , content : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => _LoadRequest :: Content { content_type : :: core :: clone :: Clone :: clone (__self_0) , content : :: core :: clone :: Clone :: clone (__self_1) , resume_position : :: core :: clone :: Clone :: clone (__self_2) , speed : :: core :: clone :: Clone :: clone (__self_3) , volume : :: core :: clone :: Clone :: clone (__self_4) , metadata : :: core :: clone :: Clone :: clone (__self_5) , request_headers : :: core :: clone :: Clone :: clone (__self_6) , } , _LoadRequest :: Video { content_type : __self_0 , url : __self_1 , resume_position : __self_2 , speed : __self_3 , volume : __self_4 , metadata : __self_5 , request_headers : __self_6 } => _LoadRequest :: Video { content_type : :: core :: clone :: Clone :: clone (__self_0) , url : :: core :: clone :: Clone :: clone (__self_1) , resume_position : :: core :: clone :: Clone :: clone (__self_2) , speed : :: core :: clone :: Clone :: clone (__self_3) , volume : :: core :: clone :: Clone :: clone (__self_4) , metadata : :: core :: clone :: Clone :: clone (__self_5) , request_headers : :: core :: clone :: Clone :: clone (__self_6) , } , _LoadRequest :: Image { content_type : __self_0 , url : __self_1 , metadata : __self_2 , request_headers : __self_3 } => _LoadRequest :: Image { content_type : :: core :: clone :: Clone :: clone (__self_0) , url : :: core :: clone :: Clone :: clone (__self_1) , metadata : :: core :: clone :: Clone :: clone (__self_2) , request_headers : :: core :: clone :: Clone :: clone (__self_3) , } , _LoadRequest :: Playlist { items : __self_0 } => _LoadRequest :: Playlist { items : :: core :: clone :: Clone :: clone (__self_0) , } , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (opaque)] pub struct CastingDevice (Arc < dyn device :: CastingDevice >) ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "impl CastingDevice { fn casting_protocol (& self) -> ProtocolType { self . 0 . casting_protocol () } fn is_ready (& self) -> bool { self . 0 . is_ready () } fn supports_feature (& self , feature : DeviceFeature) -> bool { self . 0 . supports_feature (feature) } fn name (& self) -> String { self . 0 . name () } fn set_name (& self , name : String) { self . 0 . set_name (name) ; } fn seek (& self , time_seconds : f64) -> Result < () , _CastingDeviceError > { match self . 0 . seek (time_seconds) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn stop_playback (& self) -> Result < () , _CastingDeviceError > { match self . 0 . stop_playback () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn pause_playback (& self) -> Result < () , _CastingDeviceError > { match self . 0 . pause_playback () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn resume_playback (& self) -> Result < () , _CastingDeviceError > { match self . 0 . resume_playback () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn load (& self , request : LoadRequest) -> Result < () , _CastingDeviceError > { match self . 0 . load (request) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn playlist_item_next (& self) -> Result < () , _CastingDeviceError > { match self . 0 . playlist_item_next () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn playlist_item_previous (& self) -> Result < () , _CastingDeviceError > { match self . 0 . playlist_item_previous () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } # [doc = \" Set the item index for the currently playing playlist.\"] # [doc = \"\"] # [doc = \" # Arguments\"] # [doc = \"   * `index`: zero-based index into the playlist\"] fn set_playlist_item_index (& self , index : u32) -> Result < () , _CastingDeviceError > { match self . 0 . set_playlist_item_index (index) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn change_volume (& self , volume : f64) -> Result < () , _CastingDeviceError > { match self . 0 . change_volume (volume) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn change_speed (& self , speed : f64) -> Result < () , _CastingDeviceError > { match self . 0 . change_speed (speed) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn disconnect (& self) -> Result < () , _CastingDeviceError > { match self . 0 . disconnect () { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn connect (& self , app_info : Option < ApplicationInfo > , event_handler : Arc < dyn DeviceEventHandler >) -> Result < () , _CastingDeviceError > { match self . 0 . connect (app_info , Arc :: new (DeviceEventHandlerWrapper (event_handler))) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn get_device_info (& self) -> DeviceInfo { self . 0 . get_device_info () } fn get_addresses (& self) -> Vec < IpAddr > { self . 0 . get_addresses () } fn set_addresses (& self , addrs : Vec < IpAddr >) { self . 0 . set_addresses (addrs) ; } fn get_port (& self) -> u16 { self . 0 . get_port () } fn set_port (& self , port : u16) { self . 0 . set_port (port) ; } fn subscribe_event (& self , group : GenericEventSubscriptionGroup) -> Result < () , _CastingDeviceError > { match self . 0 . subscribe_event (group) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } fn unsubscribe_event (& self , group : GenericEventSubscriptionGroup) -> Result < () , _CastingDeviceError > { match self . 0 . unsubscribe_event (group) { Ok (r) => Ok (r) , Err (err) => Err (match err { CastingDeviceError :: FailedToSendCommand => _CastingDeviceError :: FailedToSendCommand , CastingDeviceError :: MissingAddresses => _CastingDeviceError :: MissingAddresses , CastingDeviceError :: DeviceAlreadyStarted => { _CastingDeviceError :: DeviceAlreadyStarted } CastingDeviceError :: UnsupportedSubscription => { _CastingDeviceError :: UnsupportedSubscription } CastingDeviceError :: UnsupportedFeature => _CastingDeviceError :: UnsupportedFeature , }) , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "pub enum ErrorMessage { # [error (\"{0}\")] Error (String) , }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [automatically_derived] impl :: core :: fmt :: Debug for ErrorMessage { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { ErrorMessage :: Error (__self_0) => :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , \"Error\" , & __self_0) , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [allow (unused_qualifications)] # [automatically_derived] impl :: thiserror :: __private :: Error for ErrorMessage { }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [allow (unused_qualifications)] # [automatically_derived] impl :: core :: fmt :: Display for ErrorMessage { fn fmt (& self , __formatter : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use :: thiserror :: __private :: AsDisplay as _ ; # [allow (unused_variables , deprecated , clippy :: used_underscore_binding)] match self { ErrorMessage :: Error (_0) => match (_0 . as_display () ,) { (__display0 ,) => __formatter . write_fmt (format_args ! (\"{0}\" , __display0)) , } , } } }"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "# [frb (opaque)] pub struct CastContext (context :: CastContext) ;"
    },
    {
      "meta": {
        "namespace": "crate::api",
        "sources": [
          "Normal"
        ],
        "is_module_public": true
      },
      "item": "impl CastContext { # [frb (sync)] pub fn new () -> Result < Self , ErrorMessage > { Ok (Self (context :: CastContext :: new () . map_err (| err | ErrorMessage :: Error (err . to_string ())) ?)) } # [frb (sync)] pub fn create_device_from_info (& self , info : DeviceInfo) -> CastingDevice { CastingDevice (self . 0 . create_device_from_info (info)) } }"
    }
  ]
}